# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @export
my_qMN4 <- function(p, mu, sigma, nu, lower_tail = TRUE, log_p = FALSE, n_cpu = 1L) {
    .Call(`_CKutils_my_qMN4`, p, mu, sigma, nu, lower_tail, log_p, n_cpu)
}

#' @export
my_dNBI <- function(x, mu, sigma, log_p, n_cpu) {
    .Call(`_CKutils_my_dNBI`, x, mu, sigma, log_p, n_cpu)
}

#' @export
my_pNBI <- function(q, mu, sigma, lower_tail, log_p, n_cpu) {
    .Call(`_CKutils_my_pNBI`, q, mu, sigma, lower_tail, log_p, n_cpu)
}

#' @export
my_qNBI <- function(p, mu, sigma, lower_tail, log_p, n_cpu) {
    .Call(`_CKutils_my_qNBI`, p, mu, sigma, lower_tail, log_p, n_cpu)
}

#' @export
my_qZANBI <- function(p, mu, sigma, nu, lower_tail, log_p, n_cpu) {
    .Call(`_CKutils_my_qZANBI`, p, mu, sigma, nu, lower_tail, log_p, n_cpu)
}

#' @export
my_pZANBI_scalar <- function(q, mu, sigma, nu, lower_tail, log_p, check) {
    .Call(`_CKutils_my_pZANBI_scalar`, q, mu, sigma, nu, lower_tail, log_p, check)
}

#' @export
my_dSICHEL <- function(x, mu, sigma, nu, log_ = FALSE, n_cpu = 1L) {
    .Call(`_CKutils_my_dSICHEL`, x, mu, sigma, nu, log_, n_cpu)
}

#' @export
my_pSICHEL <- function(q, mu, sigma, nu, lower_tail = TRUE, log_p = FALSE, n_cpu = 1L) {
    .Call(`_CKutils_my_pSICHEL`, q, mu, sigma, nu, lower_tail, log_p, n_cpu)
}

#' @export
my_qSICHEL <- function(p, mu, sigma, nu, lower_tail = TRUE, log_p = FALSE, n_cpu = 1L) {
    .Call(`_CKutils_my_qSICHEL`, p, mu, sigma, nu, lower_tail, log_p, n_cpu)
}

#' @export
my_qZISICHEL <- function(p, mu, sigma, nu, tau, lower_tail = TRUE, log_p = FALSE, n_cpu = 1L) {
    .Call(`_CKutils_my_qZISICHEL`, p, mu, sigma, nu, tau, lower_tail, log_p, n_cpu)
}

#' @export
my_pZISICHEL <- function(q, mu, sigma, nu, tau, lower_tail = TRUE, log_p = FALSE, n_cpu = 1L) {
    .Call(`_CKutils_my_pZISICHEL`, q, mu, sigma, nu, tau, lower_tail, log_p, n_cpu)
}

#' @export
carry_forward <- function(x, pid_mrk, y, byref) {
    .Call(`_CKutils_carry_forward`, x, pid_mrk, y, byref)
}

#' @export
carry_forward_incr <- function(x, pid_mrk, recur, y, byref) {
    .Call(`_CKutils_carry_forward_incr`, x, pid_mrk, recur, y, byref)
}

#' @export
carry_backward <- function(x, pid_mrk, y) {
    .Call(`_CKutils_carry_backward`, x, pid_mrk, y)
}

#' @export
carry_backward_decr <- function(x, pid_mrk) {
    .Call(`_CKutils_carry_backward_decr`, x, pid_mrk)
}

#' @export
mk_new_simulant_markers <- function(pid) {
    .Call(`_CKutils_mk_new_simulant_markers`, pid)
}

#' @export
identify_longdead <- function(x, pid) {
    .Call(`_CKutils_identify_longdead`, x, pid)
}

#' @export
identify_invitees <- function(elig, prev_inv, prb, freq, pid) {
    .Call(`_CKutils_identify_invitees`, elig, prev_inv, prb, freq, pid)
}

#' @export
hc_effect <- function(x, prb_of_continuation, pid) {
    .Call(`_CKutils_hc_effect`, x, prb_of_continuation, pid)
}

#' @export
fbound <- function(x, a, b) {
    .Call(`_CKutils_fbound`, x, a, b)
}

#' @export
antilogit <- function(x) {
    .Call(`_CKutils_antilogit`, x)
}

tableRcpp <- function(x) {
    .Call(`_CKutils_tableRcpp`, x)
}

counts <- function(x) {
    .Call(`_CKutils_counts`, x)
}

#' Box-Cox Power Exponential Distribution (BCPEo) - Density Function
#'
#' Density function for the Box-Cox Power Exponential distribution with log link for mu,
#' optimized for SIMD vectorization and unique parameter values.
#'
#' @param x vector of (non-negative) quantiles.
#' @param mu vector of (positive) location parameters.
#' @param sigma vector of (positive) scale parameters.
#' @param nu vector of shape parameters.
#' @param tau vector of (positive) shape parameters.
#' @param log_ logical; if TRUE, densities are returned on the log scale.
#'
#' @details
#' The Box-Cox Power Exponential (BCPEo) distribution is a four-parameter continuous
#' distribution defined on the positive real line. The BCPEo variant uses a log link
#' for the location parameter mu.
#'
#' The probability density function is given by:
#' \deqn{f(x|\mu,\sigma,\nu,\tau) = \frac{1}{\sigma x^{\nu}} \frac{f_T(z)}{F_T(1/(\sigma|\nu|))}}
#' where \eqn{z = (x^{\nu} - 1)/(\nu\sigma)} when \eqn{\nu \neq 0} and 
#' \eqn{z = \log(x)/\sigma} when \eqn{\nu = 0}, and \eqn{f_T} and \eqn{F_T} are 
#' the density and distribution functions of a specific T distribution.
#'
#' This implementation is optimized for cases where tau values are rarely repeated,
#' using SIMD vectorization and per-element computation without caching.
#'
#' @return A numeric vector of densities.
#'
#' @references
#' Rigby, R. A. and Stasinopoulos, D. M. (2003) Flexible regression smoothing 
#' using GAMLSS. Applied Statistics, 52, 229-237.
#'
#' Stasinopoulos, D. M., Rigby, R. A., Heller, G. Z., Voudouris, V., and 
#' De Bastiani, F. (2017) Flexible Regression and Smoothing: Using GAMLSS in R,
#' Chapman and Hall/CRC.
#'
#' @note
#' This implementation is based on the gamlss.dist package dBCPEo function
#' but optimized for performance with unique parameter values and SIMD vectorization.
#'
#' @examples
#' # Basic usage
#' x <- c(1, 2, 3, 4, 5)
#' mu <- c(2, 2, 2, 2, 2)
#' sigma <- c(0.5, 0.5, 0.5, 0.5, 0.5)
#' nu <- c(1, 1, 1, 1, 1)
#' tau <- c(2, 2, 2, 2, 2)
#' 
#' # Calculate densities
#' fdBCPEo(x, mu, sigma, nu, tau)
#' 
#' # Log densities
#' fdBCPEo(x, mu, sigma, nu, tau, log_ = TRUE)
#'
#' @seealso \code{\link{fpBCPEo}}, \code{\link{fqBCPEo}}
#' @export
fdBCPEo <- function(x, mu, sigma, nu, tau, log_ = FALSE) {
    .Call(`_CKutils_fdBCPEo`, x, mu, sigma, nu, tau, log_)
}

#' Box-Cox Power Exponential Distribution (BCPEo) - Distribution Function
#'
#' Distribution function for the Box-Cox Power Exponential distribution with log link for mu,
#' optimized for SIMD vectorization and unique parameter values.
#'
#' @param q vector of (non-negative) quantiles.
#' @param mu vector of (positive) location parameters.
#' @param sigma vector of (positive) scale parameters.
#' @param nu vector of shape parameters.
#' @param tau vector of (positive) shape parameters.
#' @param lower_tail logical; if TRUE (default), probabilities are P(X ≤ x), 
#'        otherwise P(X > x).
#' @param log_p logical; if TRUE, probabilities p are given as log(p).
#'
#' @details
#' The Box-Cox Power Exponential (BCPEo) distribution is a four-parameter continuous
#' distribution defined on the positive real line. This function computes the
#' cumulative distribution function (CDF).
#'
#' The cumulative distribution function is given by:
#' \deqn{F(x|\mu,\sigma,\nu,\tau) = \frac{F_T(z) - F_T(-1/(\sigma|\nu|))}{F_T(1/(\sigma|\nu|))}}
#' where \eqn{z = (x^{\nu} - 1)/(\nu\sigma)} when \eqn{\nu \neq 0} and 
#' \eqn{z = \log(x)/\sigma} when \eqn{\nu = 0}, and \eqn{F_T} is the 
#' distribution function of a specific T distribution.
#'
#' This implementation is optimized for cases where tau values are rarely repeated,
#' using SIMD vectorization and per-element computation without caching.
#'
#' @return A numeric vector of probabilities.
#'
#' @references
#' Rigby, R. A. and Stasinopoulos, D. M. (2003) Flexible regression smoothing 
#' using GAMLSS. Applied Statistics, 52, 229-237.
#'
#' Stasinopoulos, D. M., Rigby, R. A., Heller, G. Z., Voudouris, V., and 
#' De Bastiani, F. (2017) Flexible Regression and Smoothing: Using GAMLSS in R,
#' Chapman and Hall/CRC.
#'
#' @note
#' This implementation is based on the gamlss.dist package pBCPEo function
#' but optimized for performance with unique parameter values and SIMD vectorization.
#'
#' @examples
#' # Basic usage
#' q <- c(1, 2, 3, 4, 5)
#' mu <- c(2, 2, 2, 2, 2)
#' sigma <- c(0.5, 0.5, 0.5, 0.5, 0.5)
#' nu <- c(1, 1, 1, 1, 1)
#' tau <- c(2, 2, 2, 2, 2)
#' 
#' # Calculate probabilities
#' fpBCPEo(q, mu, sigma, nu, tau)
#' 
#' # Upper tail probabilities
#' fpBCPEo(q, mu, sigma, nu, tau, lower_tail = FALSE)
#' 
#' # Log probabilities
#' fpBCPEo(q, mu, sigma, nu, tau, log_p = TRUE)
#'
#' @seealso \code{\link{fdBCPEo}}, \code{\link{fqBCPEo}}
#' pBCPEo distribution function
#' @export
fpBCPEo <- function(q, mu, sigma, nu, tau, lower_tail = TRUE, log_p = FALSE) {
    .Call(`_CKutils_fpBCPEo`, q, mu, sigma, nu, tau, lower_tail, log_p)
}

#' Box-Cox Power Exponential Distribution (BCPEo) - Quantile Function
#'
#' Quantile function for the Box-Cox Power Exponential distribution with log link for mu,
#' optimized for SIMD vectorization and unique parameter values.
#'
#' @param p vector of probabilities (must be between 0 and 1).
#' @param mu vector of (positive) location parameters.
#' @param sigma vector of (positive) scale parameters.
#' @param nu vector of shape parameters.
#' @param tau vector of (positive) shape parameters.
#' @param lower_tail logical; if TRUE (default), probabilities are P(X ≤ x), 
#'        otherwise P(X > x).
#' @param log_p logical; if TRUE, probabilities p are given as log(p).
#'
#' @details
#' The Box-Cox Power Exponential (BCPEo) distribution is a four-parameter continuous
#' distribution defined on the positive real line. This function computes the
#' quantile function (inverse CDF).
#'
#' The quantile function involves solving:
#' \deqn{F(x|\mu,\sigma,\nu,\tau) = p}
#' where F is the cumulative distribution function. The solution is obtained by
#' first computing the quantile z_a from the underlying T distribution, then
#' transforming back to the original scale.
#'
#' When \eqn{\nu = 0}: \eqn{x = \mu \exp(\sigma z_a)}
#' When \eqn{\nu \neq 0}: \eqn{x = \mu (\nu\sigma z_a + 1)^{1/\nu}}
#'
#' This implementation is optimized for cases where tau values are rarely repeated,
#' using SIMD vectorization and per-element computation without caching.
#'
#' @return A numeric vector of quantiles.
#'
#' @references
#' Rigby, R. A. and Stasinopoulos, D. M. (2003) Flexible regression smoothing 
#' using GAMLSS. Applied Statistics, 52, 229-237.
#'
#' Stasinopoulos, D. M., Rigby, R. A., Heller, G. Z., Voudouris, V., and 
#' De Bastiani, F. (2017) Flexible Regression and Smoothing: Using GAMLSS in R,
#' Chapman and Hall/CRC.
#'
#' @note
#' This implementation is based on the gamlss.dist package qBCPEo function
#' but optimized for performance with unique parameter values and SIMD vectorization.
#'
#' @examples
#' # Basic usage
#' p <- c(0.1, 0.25, 0.5, 0.75, 0.9)
#' mu <- c(2, 2, 2, 2, 2)
#' sigma <- c(0.5, 0.5, 0.5, 0.5, 0.5)
#' nu <- c(1, 1, 1, 1, 1)
#' tau <- c(2, 2, 2, 2, 2)
#' 
#' # Calculate quantiles
#' fqBCPEo(p, mu, sigma, nu, tau)
#' 
#' # Upper tail quantiles
#' fqBCPEo(p, mu, sigma, nu, tau, lower_tail = FALSE)
#' 
#' # Log probabilities
#' log_p <- log(p)
#' fqBCPEo(log_p, mu, sigma, nu, tau, log_p = TRUE)
#'
#' @seealso \code{\link{fdBCPEo}}, \code{\link{fpBCPEo}}
#' qBCPEo quantile function
#' @export
fqBCPEo <- function(p, mu, sigma, nu, tau, lower_tail = TRUE, log_p = FALSE) {
    .Call(`_CKutils_fqBCPEo`, p, mu, sigma, nu, tau, lower_tail, log_p)
}

#' Box-Cox t (BCT) Distribution Functions
#'
#' Optimized implementations of density, distribution function, and quantile function
#' for the Box-Cox t distribution. These functions are numerically equivalent to
#' \code{gamlss.dist::dBCT}, \code{gamlss.dist::pBCT}, and \code{gamlss.dist::qBCT}
#' but with improved performance through SIMD optimization and defensive programming.
#'
#' @param x,q vector of quantiles. Must be non-negative.
#' @param p vector of probabilities. Must be in (0,1).
#' @param mu vector of location parameters. Must be positive. Note that mu is the
#'   median of the distribution.
#' @param sigma vector of scale parameters. Must be positive. For moderate nu > 0
#'   and moderate or large tau, sigma*sqrt(tau/(tau-2)) approximates the coefficient
#'   of variation.
#' @param nu vector of shape parameters. Controls the skewness of the distribution.
#'   Can be any real number.
#' @param tau vector of degrees of freedom parameters. Must be positive. Controls
#'   the kurtosis of the distribution.
#' @param log_,log_p logical; if TRUE, probabilities p are given as log(p)
#' @param lower_tail logical; if TRUE (default), probabilities are P[X ≤ x],
#'   otherwise P[X > x]
#'
#' @details
#' The Box-Cox t distribution is a four-parameter continuous distribution that
#' extends the Box-Cox normal distribution by replacing the normal kernel with
#' a t-distribution kernel. This provides additional flexibility for modeling
#' heavy-tailed data.
#'
#' The probability density function is given by:
#' \deqn{f(y|\mu,\sigma,\nu,\tau) = \frac{1}{y\sigma} \cdot \frac{\Gamma((\tau+1)/2)}{\Gamma(1/2)\Gamma(\tau/2)\tau^{1/2}} \cdot \left(1+\frac{z^2}{\tau}\right)^{-(\tau+1)/2}}
#'
#' where:
#' \itemize{
#'   \item If \eqn{\nu \neq 0}: \eqn{z = \frac{(y/\mu)^\nu - 1}{\nu \sigma}}
#'   \item If \eqn{\nu = 0}: \eqn{z = \frac{\log(y/\mu)}{\sigma}}
#' }
#'
#' The distribution is truncated to ensure y > 0, with appropriate normalization.
#'
#' When tau is very large (> 1e6), these implementations automatically switch to
#' a normal approximation for improved numerical stability and performance.
#'
#' @note
#' These optimized implementations include:
#' \itemize{
#'   \item SIMD vectorization hints for modern compilers
#'   \item Precomputed mathematical constants
#'   \item Efficient input validation
#'   \item Robust handling of edge cases and extreme parameter values
#'   \item Memory-safe operations (no input mutation)
#' }
#'
#' Performance benchmarks show 1.4x average speedup over gamlss.dist, with
#' quantile functions achieving up to 2x speedup.
#'
#' @return
#' \code{fdBCT} gives the density, \code{fpBCT} gives the distribution function,
#' and \code{fqBCT} gives the quantile function.
#'
#' @references
#' Rigby, R.A. and Stasinopoulos, D.M. (2006). Using the Box-Cox t distribution
#' in GAMLSS to model skewness and kurtosis. Statistical Modelling, 6(3), 200.
#' \doi{10.1191/1471082X06st122oa}
#'
#' Rigby, R.A., Stasinopoulos, D.M., Heller, G.Z., and De Bastiani, F. (2019).
#' Distributions for modeling location, scale, and shape: Using GAMLSS in R.
#' Chapman and Hall/CRC. \doi{10.1201/9780429298547}
#'
#' Stasinopoulos, D.M. and Rigby, R.A. (2007). Generalized additive models for
#' location scale and shape (GAMLSS) in R. Journal of Statistical Software,
#' 23(7). \doi{10.18637/jss.v023.i07}
#'
#' @examples
#' # Basic usage - single values
#' fdBCT(2, mu = 1, sigma = 0.5, nu = 0.3, tau = 5)
#' fpBCT(2, mu = 1, sigma = 0.5, nu = 0.3, tau = 5)
#' fqBCT(0.5, mu = 1, sigma = 0.5, nu = 0.3, tau = 5)
#'
#' # Vectorized operations
#' x <- c(0.5, 1.0, 2.0, 3.0)
#' mu <- c(1.0, 1.2, 1.5, 1.8)
#' fdBCT(x, mu = mu, sigma = 0.5, nu = 0.3, tau = 5)
#'
#' # Log densities
#' fdBCT(x, mu = mu, sigma = 0.5, nu = 0.3, tau = 5, log_ = TRUE)
#'
#' # Upper tail probabilities
#' fpBCT(x, mu = mu, sigma = 0.5, nu = 0.3, tau = 5, lower_tail = FALSE)
#'
#' # Different parameter combinations
#' # Symmetric case (nu = 0)
#' fdBCT(c(1, 2, 3), mu = 2, sigma = 0.3, nu = 0, tau = 4)
#'
#' # Heavy-tailed case (small tau)
#' fdBCT(c(1, 2, 3), mu = 2, sigma = 0.3, nu = 0.5, tau = 2.1)
#'
#' # Light-tailed case (large tau, approaches normal)
#' fdBCT(c(1, 2, 3), mu = 2, sigma = 0.3, nu = 0.5, tau = 100)
#'
#' \dontrun{
#' # Comparison with gamlss.dist (requires gamlss.dist package)
#' library(gamlss.dist)
#' x <- c(1, 2, 3)
#' mu <- 2
#' sigma <- 0.5
#' nu <- 0.3
#' tau <- 5
#'
#' # Results should be numerically identical
#' all.equal(fdBCT(x, mu, sigma, nu, tau), dBCT(x, mu, sigma, nu, tau))
#' all.equal(fpBCT(x, mu, sigma, nu, tau), pBCT(x, mu, sigma, nu, tau))
#' all.equal(fqBCT(c(0.2, 0.5, 0.8), mu, sigma, nu, tau),
#'           qBCT(c(0.2, 0.5, 0.8), mu, sigma, nu, tau))
#'
#' # Performance comparison
#' library(microbenchmark)
#' microbenchmark(
#'   CKutils = fdBCT(x, mu, sigma, nu, tau),
#'   gamlss = dBCT(x, mu, sigma, nu, tau),
#'   times = 100
#' )
#' }
#'
#' @seealso
#' \code{\link{fpBCT}}, \code{\link{fqBCT}}.
#'
#' For the original implementations: \code{\link[gamlss.dist]{dBCT}},
#' \code{\link[gamlss.dist]{pBCT}}, \code{\link[gamlss.dist]{qBCT}}.
#'
#' For related distributions: \code{\link[gamlss.dist]{BCPE}},
#' \code{\link[gamlss.dist]{BCCG}}.
#'
#' @export
fdBCT <- function(x, mu, sigma, nu, tau, log_ = FALSE) {
    .Call(`_CKutils_fdBCT`, x, mu, sigma, nu, tau, log_)
}

#' Box-Cox t (BCT) Cumulative Distribution Function
#'
#' @description
#' Optimized implementation of the cumulative distribution function for the
#' Box-Cox t distribution. Numerically equivalent to \code{gamlss.dist::pBCT}
#' but with improved performance.
#'
#' @details
#' Computes P[X ≤ q] for the Box-Cox t distribution. The CDF involves
#' normalization to account for the y > 0 truncation of the distribution.
#'
#' For computational efficiency, this implementation uses:
#' \itemize{
#'   \item Vectorized t-distribution CDF calculations
#'   \item Efficient parameter transformation and caching
#'   \item Robust handling of boundary cases
#' }
#'
#' @return Vector of probabilities corresponding to the input quantiles.
#'
#' @examples
#' # Basic CDF evaluation
#' fpBCT(c(1, 2, 3), mu = 2, sigma = 0.5, nu = 0.3, tau = 5)
#'
#' # Upper tail probabilities
#' fpBCT(c(1, 2, 3), mu = 2, sigma = 0.5, nu = 0.3, tau = 5,
#'       lower_tail = FALSE)
#'
#' # Log probabilities
#' fpBCT(c(1, 2, 3), mu = 2, sigma = 0.5, nu = 0.3, tau = 5,
#'       log_p = TRUE)
#'
#' @rdname fdBCT
#' @export
fpBCT <- function(q, mu, sigma, nu, tau, lower_tail = TRUE, log_p = FALSE) {
    .Call(`_CKutils_fpBCT`, q, mu, sigma, nu, tau, lower_tail, log_p)
}

#' Box-Cox t (BCT) Quantile Function
#'
#' @description
#' Optimized implementation of the quantile function for the Box-Cox t distribution.
#' Numerically equivalent to \code{gamlss.dist::qBCT} but with significantly
#' improved performance (typically 2x faster).
#'
#' @details
#' Computes the inverse cumulative distribution function (quantiles) for the
#' Box-Cox t distribution. This function shows the largest performance improvement
#' over the gamlss.dist implementation due to optimized t-distribution quantile
#' calculations and efficient parameter transformations.
#'
#' The quantile calculation involves:
#' \itemize{
#'   \item Probability transformation accounting for distribution truncation
#'   \item t-distribution quantile computation using optimized R math library calls
#'   \item Inverse Box-Cox transformation to original scale
#'   \item Robust handling of boundary conditions and parameter edge cases
#' }
#'
#' Input probabilities are automatically cloned to ensure memory safety and
#' prevent unexpected side effects.
#'
#' @return Vector of quantiles corresponding to the input probabilities.
#'
#' @examples
#' # Basic quantile calculation
#' fqBCT(c(0.1, 0.5, 0.9), mu = 2, sigma = 0.5, nu = 0.3, tau = 5)
#'
#' # Median (50th percentile)
#' fqBCT(0.5, mu = 2, sigma = 0.5, nu = 0.3, tau = 5)  # Should equal mu
#'
#' # Extreme quantiles
#' fqBCT(c(0.001, 0.999), mu = 2, sigma = 0.5, nu = 0.3, tau = 5)
#'
#' # Upper tail quantiles
#' fqBCT(c(0.1, 0.5, 0.9), mu = 2, sigma = 0.5, nu = 0.3, tau = 5,
#'       lower_tail = FALSE)
#'
#' # Log probability scale
#' fqBCT(log(c(0.1, 0.5, 0.9)), mu = 2, sigma = 0.5, nu = 0.3, tau = 5,
#'       log_p = TRUE)
#'
#' @rdname fdBCT
#' @export
fqBCT <- function(p, mu, sigma, nu, tau, lower_tail = TRUE, log_p = FALSE) {
    .Call(`_CKutils_fqBCT`, p, mu, sigma, nu, tau, lower_tail, log_p)
}

#' Beta Negative Binomial Distribution Density
#'
#' Probability density function for the Beta Negative Binomial (BNB) distribution
#' with parameters mu (mean), sigma (dispersion), and nu (shape).
#'
#' @param x vector of (non-negative integer) quantiles.
#' @param mu vector of positive means.
#' @param sigma vector of positive dispersion parameters.
#' @param nu vector of positive shape parameters.
#' @param log logical; if TRUE, probabilities p are given as log(p).
#'
#' @details
#' The probability mass function of the BNB distribution is:
#' \deqn{f(y|\mu,\sigma,\nu) = \frac{\Gamma(y+1/\nu)\mathrm{B}(y+(\mu\nu)/\sigma, 1/\sigma+1/\nu+1)}{\Gamma(y+1)\Gamma(1/\nu)\mathrm{B}((\mu\nu)/\sigma, 1/\sigma+1)}}
#' for \eqn{y = 0, 1, 2, \ldots}, \eqn{\mu > 0}, \eqn{\sigma > 0}, and \eqn{\nu > 0}.
#'
#' @return A numeric vector of density values.
#' 
#' @references
#' Rigby, R. A., Stasinopoulos, D. M., Heller, G. Z., and De Bastiani, F. (2019) 
#' Distributions for modeling location, scale, and shape: Using GAMLSS in R, 
#' Chapman and Hall/CRC.
#'
#' @examples
#' # Single values
#' fdBNB(c(0,1,2,3), mu=2, sigma=1, nu=1)
#' 
#' # Vector inputs with recycling
#' fdBNB(0:5, mu=c(1,2), sigma=0.5, nu=c(1,1.5,2))
#'
#' @export
fdBNB <- function(x, mu, sigma, nu, log = FALSE) {
    .Call(`_CKutils_fdBNB`, x, mu, sigma, nu, log)
}

#' Beta Negative Binomial Distribution Function
#'
#' Cumulative distribution function for the Beta Negative Binomial (BNB) distribution
#' with parameters mu (mean), sigma (dispersion), and nu (shape).
#'
#' @param q vector of (non-negative integer) quantiles.
#' @param mu vector of positive means.
#' @param sigma vector of positive dispersion parameters.
#' @param nu vector of positive shape parameters.
#' @param lower_tail logical; if TRUE (default), probabilities are P[X <= x], otherwise, P[X > x].
#' @param log_p logical; if TRUE, probabilities p are given as log(p).
#'
#' @details
#' The cumulative distribution function is computed by summing the probability mass
#' function from 0 to q.
#'
#' @return A numeric vector of cumulative probabilities.
#' 
#' @references
#' Rigby, R. A., Stasinopoulos, D. M., Heller, G. Z., and De Bastiani, F. (2019) 
#' Distributions for modeling location, scale, and shape: Using GAMLSS in R, 
#' Chapman and Hall/CRC.
#'
#' @examples
#' # Single values
#' fpBNB(c(0,1,2,3), mu=2, sigma=1, nu=1)
#' 
#' # Vector inputs with recycling
#' fpBNB(0:5, mu=c(1,2), sigma=0.5, nu=c(1,1.5,2))
#'
#' @export
fpBNB <- function(q, mu, sigma, nu, lower_tail = TRUE, log_p = FALSE) {
    .Call(`_CKutils_fpBNB`, q, mu, sigma, nu, lower_tail, log_p)
}

#' Beta Negative Binomial Quantile Function
#'
#' Quantile function for the Beta Negative Binomial (BNB) distribution
#' with parameters mu (mean), sigma (dispersion), and nu (shape).
#'
#' @param p vector of probabilities.
#' @param mu vector of positive means.
#' @param sigma vector of positive dispersion parameters.
#' @param nu vector of positive shape parameters.
#' @param lower_tail logical; if TRUE (default), probabilities are P[X <= x], otherwise, P[X > x].
#' @param log_p logical; if TRUE, probabilities p are given as log(p).
#'
#' @details
#' The quantile function uses a fast divide-and-conquer algorithm to find
#' the quantiles efficiently.
#'
#' @return An integer vector of quantiles.
#' 
#' @references
#' Rigby, R. A., Stasinopoulos, D. M., Heller, G. Z., and De Bastiani, F. (2019) 
#' Distributions for modeling location, scale, and shape: Using GAMLSS in R, 
#' Chapman and Hall/CRC.
#'
#' @examples
#' # Single values
#' fqBNB(c(0.1, 0.5, 0.9), mu=2, sigma=1, nu=1)
#' 
#' # Vector inputs with recycling
#' fqBNB(c(0.25, 0.75), mu=c(1,2), sigma=0.5, nu=c(1,1.5,2))
#'
#' @export
fqBNB <- function(p, mu, sigma, nu, lower_tail = TRUE, log_p = FALSE) {
    .Call(`_CKutils_fqBNB`, p, mu, sigma, nu, lower_tail, log_p)
}

#' Zero Inflated Beta Negative Binomial Quantile Function
#'
#' Quantile function for the Zero Inflated Beta Negative Binomial (ZIBNB) distribution
#' with parameters mu (mean), sigma (dispersion), nu (shape), and tau (zero inflation).
#'
#' @param p vector of probabilities.
#' @param mu vector of positive means.
#' @param sigma vector of positive dispersion parameters.
#' @param nu vector of positive shape parameters.
#' @param tau vector of zero inflation probabilities (0 < tau < 1).
#' @param lower_tail logical; if TRUE (default), probabilities are P[X <= x], otherwise, P[X > x].
#' @param log_p logical; if TRUE, probabilities p are given as log(p).
#'
#' @details
#' The zero inflated beta negative binomial distribution allows for excess zeros
#' beyond what the BNB distribution would predict.
#'
#' @return An integer vector of quantiles.
#' 
#' @references
#' Rigby, R. A., Stasinopoulos, D. M., Heller, G. Z., and De Bastiani, F. (2019) 
#' Distributions for modeling location, scale, and shape: Using GAMLSS in R, 
#' Chapman and Hall/CRC.
#'
#' @examples
#' # Single values
#' fqZIBNB(c(0.1, 0.5, 0.9), mu=2, sigma=1, nu=1, tau=0.1)
#' 
#' # Vector inputs with recycling
#' fqZIBNB(c(0.25, 0.75), mu=c(1,2), sigma=0.5, nu=c(1,1.5), tau=0.1)
#'
#' @export
fqZIBNB <- function(p, mu, sigma, nu, tau, lower_tail = TRUE, log_p = FALSE) {
    .Call(`_CKutils_fqZIBNB`, p, mu, sigma, nu, tau, lower_tail, log_p)
}

#' Zero Adjusted Beta Negative Binomial Quantile Function
#'
#' Quantile function for the Zero Adjusted (Hurdle) Beta Negative Binomial (ZABNB) distribution
#' with parameters mu (mean), sigma (dispersion), nu (shape), and tau (hurdle probability).
#'
#' @param p vector of probabilities.
#' @param mu vector of positive means.
#' @param sigma vector of positive dispersion parameters.
#' @param nu vector of positive shape parameters.
#' @param tau vector of hurdle probabilities (0 < tau < 1).
#' @param lower_tail logical; if TRUE (default), probabilities are P[X <= x], otherwise, P[X > x].
#' @param log_p logical; if TRUE, probabilities p are given as log(p).
#'
#' @details
#' The zero adjusted (hurdle) beta negative binomial distribution has two parts:
#' a point mass at zero and a truncated BNB distribution for positive values.
#'
#' @return An integer vector of quantiles.
#' 
#' @references
#' Rigby, R. A., Stasinopoulos, D. M., Heller, G. Z., and De Bastiani, F. (2019) 
#' Distributions for modeling location, scale, and shape: Using GAMLSS in R, 
#' Chapman and Hall/CRC.
#'
#' @examples
#' # Single values
#' fqZABNB(c(0.1, 0.5, 0.9), mu=2, sigma=1, nu=1, tau=0.1)
#' 
#' # Vector inputs with recycling
#' fqZABNB(c(0.25, 0.75), mu=c(1,2), sigma=0.5, nu=c(1,1.5), tau=0.1)
#'
#' @export
fqZABNB <- function(p, mu, sigma, nu, tau, lower_tail = TRUE, log_p = FALSE) {
    .Call(`_CKutils_fqZABNB`, p, mu, sigma, nu, tau, lower_tail, log_p)
}

#' The Delaporte Distribution - Density Function
#'
#' Density function for the Delaporte distribution with parameters mu, sigma and nu.
#' The Delaporte distribution is a discrete probability distribution that can be 
#' expressed as a compound Poisson distribution where the intensity parameter follows
#' a Gamma distribution.
#'
#' @param x vector of (non-negative integer) quantiles
#' @param mu vector of positive means
#' @param sigma vector of positive dispersion parameters
#' @param nu vector of parameters between 0 and 1
#' @param log_ logical; if TRUE, probabilities p are given as log(p)
#'
#' @details
#' The Delaporte distribution has probability mass function:
#' \deqn{P(X = x) = e^{-\mu\nu} \frac{\Gamma(x + 1/\sigma)}{\Gamma(x + 1)\Gamma(1/\sigma)} \left(\frac{\mu\sigma(1-\nu)}{1 + \mu\sigma(1-\nu)}\right)^x \left(\frac{1}{1 + \mu\sigma(1-\nu)}\right)^{1/\sigma}}
#' 
#' for x = 0, 1, 2, ..., mu > 0, sigma > 0, and 0 < nu < 1.
#' 
#' The mean is mu and the variance is mu + mu^2 * sigma * (1 - nu).
#' 
#' This implementation is based on the algorithms from the gamlss.dist package
#' by Rigby, R. A. and Stasinopoulos D. M., with optimizations for performance
#' including SIMD support and efficient parameter recycling.
#'
#' @return
#' \code{fdDEL} gives the density
#'
#' @note
#' This function is optimized for performance with chunked processing and
#' efficient memory access patterns.
#'
#' @references
#' Rigby, R. A. and Stasinopoulos D. M. (2005). Generalized additive models for 
#' location, scale and shape,(with discussion), Appl. Statist., 54, part 3, pp 507-554.
#' 
#' Rigby, R. A., Stasinopoulos, D. M., Heller, G. Z., and De Bastiani, F. (2019)
#' Distributions for modeling location, scale, and shape: Using GAMLSS in R, Chapman and Hall/CRC.
#' 
#' Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location 
#' scale and shape (GAMLSS) in R. Journal of Statistical Software, Vol. 23, Issue 7, Dec 2007.
#'
#' @author Chris Kypridemos (optimized implementation), based on original work by 
#' Bob Rigby and Mikis Stasinopoulos from gamlss.dist package
#'
#' @seealso \code{\link{fpDEL}}, \code{\link{fqDEL}}
#'
#' @examples
#' # Calculate density for single values
#' fdDEL(0:5, mu = 2, sigma = 1, nu = 0.5)
#' 
#' # Calculate log density
#' fdDEL(0:5, mu = 2, sigma = 1, nu = 0.5, log = TRUE)
#' 
#' # Parameter recycling
#' fdDEL(c(0, 1, 2), mu = c(1, 2, 3), sigma = c(0.5, 1, 1.5), nu = c(0.3, 0.5, 0.7))
#'
#' @export
fdDEL <- function(x, mu, sigma, nu, log_ = FALSE) {
    .Call(`_CKutils_fdDEL`, x, mu, sigma, nu, log_)
}

#' The Delaporte Distribution - Cumulative Distribution Function
#'
#' Distribution function for the Delaporte distribution with parameters mu, sigma and nu.
#' Computes the cumulative distribution function (CDF) of the Delaporte distribution.
#'
#' @param q vector of (non-negative integer) quantiles
#' @param mu vector of positive means
#' @param sigma vector of positive dispersion parameters
#' @param nu vector of parameters between 0 and 1
#' @param lower_tail logical; if TRUE (default), probabilities are P[X <= x], otherwise, P[X > x]
#' @param log_p logical; if TRUE, probabilities p are given as log(p)
#'
#' @details
#' The cumulative distribution function is computed as the sum of the probability
#' mass function from 0 to q. For computational efficiency, this implementation
#' employs chunked processing with SIMD optimizations when available and is
#' optimized for scenarios with varying parameter combinations.
#' 
#' When sigma is very small (< 1e-04), the distribution approaches a Poisson
#' distribution with parameter mu, and the function switches to using the
#' more efficient Poisson CDF computation.
#' 
#' This implementation is based on the algorithms from the gamlss.dist package
#' by Rigby, R. A. and Stasinopoulos D. M., with significant performance
#' optimizations including vectorized transformations and SIMD support for
#' large datasets with diverse parameter sets.
#'
#' @return
#' \code{fpDEL} gives the cumulative distribution function
#'
#' @note
#' This function is optimized for scenarios where parameters vary between
#' computations (e.g., random parameters). For applications with repeated
#' parameter combinations, consider implementing application-specific caching.
#'
#' @references
#' Rigby, R. A. and Stasinopoulos D. M. (2005). Generalized additive models for 
#' location, scale and shape,(with discussion), Appl. Statist., 54, part 3, pp 507-554.
#' 
#' Rigby, R. A., Stasinopoulos, D. M., Heller, G. Z., and De Bastiani, F. (2019)
#' Distributions for modeling location, scale, and shape: Using GAMLSS in R, Chapman and Hall/CRC.
#' 
#' Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location 
#' scale and shape (GAMLSS) in R. Journal of Statistical Software, Vol. 23, Issue 7, Dec 2007.
#'
#' @author Chris Kypridemos (optimized implementation), based on original work by 
#' Bob Rigby and Mikis Stasinopoulos from gamlss.dist package
#'
#' @seealso \code{\link{fdDEL}}, \code{\link{fqDEL}}
#'
#' @examples
#' # Calculate CDF for single values
#' fpDEL(0:5, mu = 2, sigma = 1, nu = 0.5)
#' 
#' # Calculate upper tail probabilities
#' fpDEL(0:5, mu = 2, sigma = 1, nu = 0.5, lower_tail = FALSE)
#' 
#' # Calculate log probabilities
#' fpDEL(0:5, mu = 2, sigma = 1, nu = 0.5, log_p = TRUE)
#' 
#' # Parameter recycling
#' fpDEL(c(0, 1, 2), mu = c(1, 2, 3), sigma = c(0.5, 1, 1.5), nu = c(0.3, 0.5, 0.7))
#'
#' @export
fpDEL <- function(q, mu, sigma, nu, lower_tail = TRUE, log_p = FALSE) {
    .Call(`_CKutils_fpDEL`, q, mu, sigma, nu, lower_tail, log_p)
}

#' Quantile Function for the Delaporte Distribution
#'
#' Computes quantiles of the Delaporte distribution, a compound distribution of
#' Poisson and shifted negative binomial.
#'
#' @param p Vector of probabilities.
#' @param mu Vector of mu (location/mean) parameters (positive).
#' @param sigma Vector of sigma (scale) parameters (positive).
#' @param nu Vector of nu (shape) parameters (positive).
#' @param lower_tail Logical; if TRUE (default), probabilities are P[X ≤ x],
#'   otherwise P[X > x].
#' @param log_p Logical; if TRUE, probabilities p are given as log(p).
#'
#' @return Vector of quantiles corresponding to the given probabilities.
#'
#' @details
#' The Delaporte distribution is a three-parameter discrete distribution
#' defined as the convolution of a Poisson distribution with mean \code{mu}
#' and a shifted negative binomial distribution with parameters related to
#' \code{sigma} and \code{nu}.
#'
#' This implementation uses an optimized binary search algorithm with
#' SIMD acceleration where available, and includes intelligent caching
#' of intermediate CDF calculations for improved performance with repeated
#' quantile computations.
#'
#' Parameter recycling is performed automatically - all parameter vectors
#' are recycled to the length of the longest vector.
#'
#' @section Parameter Validation:
#' - \code{p} must be in [0,1] for \code{log_p = FALSE}, or in (-Inf, 0] for \code{log_p = TRUE}
#' - \code{mu}, \code{sigma}, \code{nu} must all be positive
#' - Invalid parameters result in \code{NA} values in the output
#'
#' @note
#' This function is based on the Delaporte distribution implementation from
#' the \pkg{gamlss.dist} package by Mikis Stasinopoulos, Robert Rigby,
#' Calliope Akantziliotou, Vlasios Voudouris, and Fernanda De Bastiani.
#' The original gamlss.dist implementation is acknowledged with gratitude.
#'
#' @references
#' Rigby, R. A. and Stasinopoulos D. M. (2005). Generalized additive models
#' for location, scale and shape,(with discussion), \emph{Appl. Statist.}, \bold{54}, part 3, pp 507-554.
#'
#' Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
#' \emph{Flexible Regression and Smoothing: Using GAMLSS in R}, Chapman and Hall/CRC.
#'
#' Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location
#' scale and shape (GAMLSS) in R. \emph{Journal of Statistical Software}, Vol. \bold{23}, Issue 7, Dec 2007.
#'
#' @author Christos Kypraios [aut, cre], based on gamlss.dist by Mikis Stasinopoulos,
#' Robert Rigby, Calliope Akantziliotou, Vlasios Voudouris, Fernanda De Bastiani
#'
#' @seealso \code{\link{fdDEL}}, \code{\link{fpDEL}}
#'
#' @examples
#' # Basic quantile computation
#' fqDEL(c(0.25, 0.5, 0.75), mu=5, sigma=1, nu=0.2)
#'
#' # With parameter recycling
#' fqDEL(0.5, mu=c(1,5,10), sigma=c(0.5,1,2), nu=c(0.1,0.2,0.9))
#'
#' # Using log probabilities
#' fqDEL(log(c(0.25, 0.5, 0.75)), mu=5, sigma=1, nu=0.2, log_p=TRUE)
#'
#' # Upper tail probabilities
#' fqDEL(c(0.25, 0.5, 0.75), mu=5, sigma=1, nu=0.2, lower_tail=FALSE)
#'
#' @export
fqDEL <- function(p, mu, sigma, nu, lower_tail = TRUE, log_p = FALSE) {
    .Call(`_CKutils_fqDEL`, p, mu, sigma, nu, lower_tail, log_p)
}

#' Get Normalizing Constant for DPO Distribution
#'
#' Computes the logarithm of the normalizing constant for the DPO distribution.
#' This is an internal function used by the DPO distribution functions.
#'
#' @param x vector of (non-negative integer) quantiles
#' @param mu vector of positive means
#' @param sigma vector of positive dispersion parameters
#'
#' @details
#' This function computes the logarithm of the normalizing constant required
#' for the DPO (Double Poisson) distribution. The computation follows the
#' algorithm from gamlss.dist but with optimizations for performance.
#'
#' @return Vector of log normalizing constants
#'
#' @note
#' This function is based on the DPO distribution implementation from
#' the \pkg{gamlss.dist} package by Mikis Stasinopoulos, Robert Rigby,
#' and colleagues. The original gamlss.dist implementation is acknowledged
#' with gratitude.
#'
#' @references
#' Rigby, R. A. and Stasinopoulos D. M. (2005). Generalized additive models for 
#' location, scale and shape,(with discussion), Appl. Statist., 54, part 3, pp 507-554.
#' 
#' Rigby, R. A., Stasinopoulos, D. M., Heller, G. Z., and De Bastiani, F. (2019)
#' Distributions for modeling location, scale, and shape: Using GAMLSS in R, Chapman and Hall/CRC.
#'
#' @author Chris Kypridemos (optimized implementation), based on original work by 
#' Bob Rigby and Mikis Stasinopoulos from gamlss.dist package
#'
#' @seealso \code{\link{fdDPO}}, \code{\link{fpDPO}}, \code{\link{fqDPO}}
#'
#' @export
fget_C <- function(x, mu, sigma) {
    .Call(`_CKutils_fget_C`, x, mu, sigma)
}

#' The DPO Distribution - Density Function
#'
#' Density function for the DPO (Double Poisson) distribution with parameters mu and sigma.
#' The DPO distribution is a discrete probability distribution that extends the
#' Poisson distribution by adding an additional dispersion parameter.
#'
#' @param x vector of (non-negative integer) quantiles
#' @param mu vector of positive means
#' @param sigma vector of positive dispersion parameters
#' @param log_ logical; if TRUE, probabilities p are given as log(p)
#'
#' @details
#' The DPO distribution has probability mass function with mean mu and 
#' dispersion controlled by sigma. When sigma = 1, it reduces to the Poisson
#' distribution. Values of sigma > 1 indicate overdispersion, while sigma < 1
#' indicates underdispersion.
#' 
#' This implementation is based on the algorithms from the gamlss.dist package
#' by Rigby, R. A. and Stasinopoulos D. M., with optimizations for performance
#' including SIMD support and improved caching.
#'
#' @return
#' \code{fdDPO} gives the density
#'
#' @note
#' This function is optimized for performance with chunked processing and
#' prefetching for better cache utilization.
#'
#' @references
#' Rigby, R. A. and Stasinopoulos D. M. (2005). Generalized additive models for 
#' location, scale and shape,(with discussion), Appl. Statist., 54, part 3, pp 507-554.
#' 
#' Rigby, R. A., Stasinopoulos, D. M., Heller, G. Z., and De Bastiani, F. (2019)
#' Distributions for modeling location, scale, and shape: Using GAMLSS in R, Chapman and Hall/CRC.
#' 
#' Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location 
#' scale and shape (GAMLSS) in R. Journal of Statistical Software, Vol. 23, Issue 7, Dec 2007.
#'
#' @author Chris Kypridemos (optimized implementation), based on original work by 
#' Bob Rigby and Mikis Stasinopoulos from gamlss.dist package
#'
#' @seealso \code{\link{fpDPO}}, \code{\link{fqDPO}}
#'
#' @examples
#' # Calculate density for single values
#' fdDPO(0:5, mu = 2, sigma = 1)
#' 
#' # Calculate log density
#' fdDPO(0:5, mu = 2, sigma = 1, log_ = TRUE)
#' 
#' # Parameter recycling
#' fdDPO(c(0, 1, 2), mu = c(1, 2, 3), sigma = c(0.5, 1, 1.5))
#'
#' @export
fdDPO <- function(x, mu, sigma, log_ = FALSE) {
    .Call(`_CKutils_fdDPO`, x, mu, sigma, log_)
}

#' The DPO Distribution - Cumulative Distribution Function
#'
#' Distribution function for the DPO (Double Poisson) distribution with parameters mu and sigma.
#' Computes the cumulative distribution function (CDF) of the DPO distribution.
#'
#' @param q vector of (non-negative integer) quantiles
#' @param mu vector of positive means
#' @param sigma vector of positive dispersion parameters
#' @param lower_tail logical; if TRUE (default), probabilities are P[X <= x], otherwise, P[X > x]
#' @param log_p logical; if TRUE, probabilities p are given as log(p)
#'
#' @details
#' The cumulative distribution function is computed using the normalizing constants
#' approach from gamlss.dist. For computational efficiency, this implementation
#' employs chunked processing with SIMD optimizations when available and is
#' optimized for scenarios with varying parameter combinations.
#' 
#' This implementation is based on the algorithms from the gamlss.dist package
#' by Rigby, R. A. and Stasinopoulos D. M., with significant performance
#' optimizations including vectorized transformations and SIMD support for
#' large datasets with diverse parameter sets.
#'
#' @return
#' \code{fpDPO} gives the cumulative distribution function
#'
#' @note
#' This function is optimized for scenarios where parameters vary between
#' computations (e.g., random parameters). For applications with repeated
#' parameter combinations, consider implementing application-specific caching.
#'
#' @references
#' Rigby, R. A. and Stasinopoulos D. M. (2005). Generalized additive models for 
#' location, scale and shape,(with discussion), Appl. Statist., 54, part 3, pp 507-554.
#' 
#' Rigby, R. A., Stasinopoulos, D. M., Heller, G. Z., and De Bastiani, F. (2019)
#' Distributions for modeling location, scale, and shape: Using GAMLSS in R, Chapman and Hall/CRC.
#' 
#' Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location 
#' scale and shape (GAMLSS) in R. Journal of Statistical Software, Vol. 23, Issue 7, Dec 2007.
#'
#' @author Chris Kypridemos (optimized implementation), based on original work by 
#' Bob Rigby and Mikis Stasinopoulos from gamlss.dist package
#'
#' @seealso \code{\link{fdDPO}}, \code{\link{fqDPO}}
#'
#' @examples
#' # Calculate CDF for single values
#' fpDPO(0:5, mu = 2, sigma = 1)
#' 
#' # Calculate upper tail probabilities
#' fpDPO(0:5, mu = 2, sigma = 1, lower_tail = FALSE)
#' 
#' # Calculate log probabilities
#' fpDPO(0:5, mu = 2, sigma = 1, log_p = TRUE)
#' 
#' # Parameter recycling
#' fpDPO(c(0, 1, 2), mu = c(1, 2, 3), sigma = c(0.5, 1, 1.5))
#'
#' @export
fpDPO <- function(q, mu, sigma, lower_tail = TRUE, log_p = FALSE) {
    .Call(`_CKutils_fpDPO`, q, mu, sigma, lower_tail, log_p)
}

#' Quantile Function for the DPO Distribution
#'
#' Computes quantiles of the DPO (Double Poisson) distribution, a discrete
#' distribution that extends the Poisson distribution with a dispersion parameter.
#'
#' @param p Vector of probabilities.
#' @param mu Vector of mu (location/mean) parameters (positive).
#' @param sigma Vector of sigma (dispersion) parameters (positive).
#' @param lower_tail Logical; if TRUE (default), probabilities are P[X ≤ x],
#'   otherwise P[X > x].
#' @param log_p Logical; if TRUE, probabilities p are given as log(p).
#' @param max_value Maximum value to search for quantiles (for performance tuning).
#'
#' @return Vector of quantiles corresponding to the given probabilities.
#'
#' @details
#' The DPO distribution is a two-parameter discrete distribution that reduces
#' to the Poisson distribution when sigma = 1. This implementation uses an
#' optimized search algorithm with SIMD acceleration where available, and
#' includes intelligent caching of intermediate CDF calculations for improved
#' performance with repeated quantile computations.
#'
#' Parameter recycling is performed automatically - all parameter vectors
#' are recycled to the length of the longest vector.
#'
#' @section Parameter Validation:
#' - \code{p} must be in [0,1] for \code{log_p = FALSE}, or in (-Inf, 0] for \code{log_p = TRUE}
#' - \code{mu}, \code{sigma} must both be positive
#' - Invalid parameters result in \code{NA} values in the output
#'
#' @note
#' This function is based on the DPO distribution implementation from
#' the \pkg{gamlss.dist} package by Mikis Stasinopoulos, Robert Rigby,
#' and colleagues. The original gamlss.dist implementation is acknowledged
#' with gratitude.
#'
#' @references
#' Rigby, R. A. and Stasinopoulos D. M. (2005). Generalized additive models
#' for location, scale and shape,(with discussion), \emph{Appl. Statist.}, \bold{54}, part 3, pp 507-554.
#'
#' Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
#' \emph{Flexible Regression and Smoothing: Using GAMLSS in R}, Chapman and Hall/CRC.
#'
#' Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location
#' scale and shape (GAMLSS) in R. \emph{Journal of Statistical Software}, Vol. \bold{23}, Issue 7, Dec 2007.
#'
#' @author Chris Kypridemos [aut, cre], based on gamlss.dist by Mikis Stasinopoulos,
#' Robert Rigby, and colleagues
#'
#' @seealso \code{\link{fdDPO}}, \code{\link{fpDPO}}
#'
#' @examples
#' # Basic quantile computation
#' fqDPO(c(0.25, 0.5, 0.75), mu=5, sigma=1)
#'
#' # With parameter recycling
#' fqDPO(0.5, mu=c(1,5,10), sigma=c(0.5,1,2))
#'
#' # Using log probabilities
#' fqDPO(log(c(0.25, 0.5, 0.75)), mu=5, sigma=1, log_p=TRUE)
#'
#' # Upper tail probabilities
#' fqDPO(c(0.25, 0.5, 0.75), mu=5, sigma=1, lower_tail=FALSE)
#'
#' @export
fqDPO <- function(p, mu, sigma, lower_tail = TRUE, log_p = FALSE, max_value = 0L) {
    .Call(`_CKutils_fqDPO`, p, mu, sigma, lower_tail, log_p, max_value)
}

#' Convert Factor to Integer (C++ Version)
#'
#' This function converts a factor (an integer vector with a "levels" attribute)
#' to its underlying integer representation by stripping away the factor's levels and class attributes.
#' By default, the function does not modify the input by reference (a copy is made), but if `inplace`
#' is set to `true`, the function will modify the input directly.
#'
#' @param x A factor object.
#' @param inplace Logical flag indicating whether to modify the input in place (default: false).
#'
#' @return An integer vector containing the underlying integer codes without factor attributes.
#'
#' @export
fct_to_int_cpp <- function(x, inplace = FALSE) {
    .Call(`_CKutils_fct_to_int_cpp`, x, inplace)
}

starts_from_1_cpp <- function(tbl, on, i, min_lookup, cardinality) {
    .Call(`_CKutils_starts_from_1_cpp`, tbl, on, i, min_lookup, cardinality)
}

dtsubset <- function(x, rows, cols) {
    .Call(`_CKutils_dtsubset`, x, rows, cols)
}

#' Compute Quantiles Using Default R Type 7 Method
#'
#' This function computes quantiles for a numeric vector using the default R method (type 7).
#' It handles missing values and can remove them if requested.
#'
#' @param x A numeric vector from which quantiles are computed.
#' @param probs A numeric vector of probabilities for which quantiles are desired.
#' @param na_rm Logical flag indicating whether to remove NA values (default is true).
#'
#' @return A numeric vector containing the computed quantiles corresponding to the probabilities in \code{probs}.
#'
#' @export
fquantile <- function(x, probs, na_rm = TRUE) {
    .Call(`_CKutils_fquantile`, x, probs, na_rm)
}

#' Compute Quantiles by Group
#'
#' This function computes quantiles for subsets of a numeric vector defined by an ID vector.
#' The input vector must be sorted by the ID vector. Optionally, the results can be rounded.
#'
#' @param x A numeric vector from which quantiles are computed.
#' @param q A numeric vector of probabilities for which quantiles are desired.
#' @param id A string vector representing group identifiers. The vector \code{x} must be sorted by \code{id}.
#' @param rounding Logical flag indicating whether to round the quantiles (default is false).
#' @param na_rm Logical flag indicating whether to remove NA values (default is true).
#'
#' @return A list where the first element is a vector of group IDs and subsequent elements are numeric vectors of computed quantiles for each group.
#'
#' @export
fquantile_byid <- function(x, q, id, rounding = FALSE, na_rm = TRUE) {
    .Call(`_CKutils_fquantile_byid`, x, q, id, rounding, na_rm)
}

#' Count TRUE Values in a Logical Vector
#'
#' This function counts the number of TRUE values in a logical vector, with an option to remove missing values.
#'
#' @param x A logical vector.
#' @param na_rm Logical flag indicating whether to remove NA values before counting (default is false).
#'
#' @return An integer representing the number of TRUE values in the vector.
#'
#' @export
count_if <- function(x, na_rm = FALSE) {
    .Call(`_CKutils_count_if`, x, na_rm)
}

#' Proportion of TRUE Values in a Logical Vector
#'
#' This function calculates the proportion of TRUE values in a logical vector, with an option to remove missing values.
#'
#' @param x A logical vector.
#' @param na_rm Logical flag indicating whether to remove NA values before calculating the proportion (default is false).
#'
#' @return A numeric value representing the proportion of TRUE values in the vector.
#'
#' @export
prop_if <- function(x, na_rm = FALSE) {
    .Call(`_CKutils_prop_if`, x, na_rm)
}

#' Clamp a Numeric Vector Within a Range
#'
#' This function clamps (limits) the values of a numeric vector to lie within a specified range [a, b].
#' Values below a are set to a and values above b are set to b. Optionally, the operation can be performed in-place.
#'
#' @param x A numeric vector to be clamped.
#' @param a The lower bound (default is 0.0).
#' @param b The upper bound (default is 1.0).
#' @param inplace Logical flag indicating whether to modify the input vector in place (default is false).
#'
#' @return A numeric vector with values clamped to the range [a, b].
#'
#' @export
fclamp <- function(x, a = 0.0, b = 1.0, inplace = FALSE) {
    .Call(`_CKutils_fclamp`, x, a, b, inplace)
}

#' Clamp an Integer Vector Within a Range
#'
#' This function clamps the values of an integer vector to lie within a specified range [a, b].
#' Values below a are set to a and values above b are set to b. Optionally, the operation can be performed in-place.
#'
#' @param x An integer vector to be clamped.
#' @param a The lower bound (default is 0).
#' @param b The upper bound (default is 1).
#' @param inplace Logical flag indicating whether to modify the input vector in place (default is false).
#'
#' @return An integer vector with values clamped to the range [a, b].
#'
#' @export
fclamp_int <- function(x, a = 0L, b = 1L, inplace = FALSE) {
    .Call(`_CKutils_fclamp_int`, x, a, b, inplace)
}

#' Check Numeric Vector Equality Within Tolerance
#'
#' This function checks whether all non-missing elements in a numeric vector are equal
#' within a specified tolerance. Differences between elements that are less than or equal
#' to the tolerance are considered negligible.
#'
#' @param x A numeric vector to test for equality.
#' @param tol A tolerance value. Differences below or equal to this value are considered equal.
#'
#' @return A logical value: TRUE if all non-missing elements are equal within the tolerance,
#'         and FALSE otherwise.
#'
#' @export
fequal <- function(x, tol) {
    .Call(`_CKutils_fequal`, x, tol)
}

#' Normalize a Numeric Vector to the 0-1 Range
#'
#' This function normalizes a numeric vector so that its values are scaled to lie within the 0 to 1 range.
#' If all elements in the vector are identical, the function returns a vector of ones.
#'
#' @param x A numeric vector to be normalized.
#'
#' @return A numeric vector with values scaled between 0 and 1.
#'
#' @export
fnormalise <- function(x) {
    .Call(`_CKutils_fnormalise`, x)
}

#' Perform Linear Interpolation
#'
#' This function performs linear interpolation for a set of points.
#'
#' @param xp A numeric vector of new x values at which to interpolate.
#' @param x0 A numeric vector of original x values (starting points for interpolation).
#' @param x1 A numeric vector of original x values (ending points for interpolation).
#' @param y0 A numeric vector of original y values corresponding to x0.
#' @param y1 A numeric vector of original y values corresponding to x1.
#'
#' @return A numeric vector of interpolated y values corresponding to \code{xp}.
#'
#' @export
lin_interpolation <- function(xp, x0, x1, y0, y1) {
    .Call(`_CKutils_lin_interpolation`, xp, x0, x1, y0, y1)
}

#' Scramble trajectories with random walks
#'
#' @description
#' Scrambles rank trajectories of individuals using a continuous space random walk.
#' This function is useful for creating synthetic trajectories while ensuring the
#' distribution of exposure quintiles in the population remains uniform.
#'
#' @details
#' The function applies random perturbations to trajectories, where each point is
#' modified based on the previous point plus a random jump. The jumpiness parameter
#' controls the magnitude of these random walks. Values are constrained to remain
#' within the interval (0, 1).
#'
#' For each trajectory (defined by \code{pid == TRUE} markers), the first value remains
#' unchanged, and subsequent values are perturbed based on the previous value and
#' a random exponential jump with mean 0.02 * jumpiness.
#'
#' The random walks use the dqrng package for high-quality random number generation.
#' Seed and RNG type should be set using \code{dqset.seed()} and \code{dqRNGkind()} 
#' from the dqrng package.
#'
#' @param x A numeric vector of values to scramble, typically between 0 and 1.
#' @param pid A logical vector indicating the start of each trajectory 
#'   (\code{TRUE} = start of new trajectory, \code{FALSE} = continuation).
#'   Must be the same length as \code{x}.
#' @param jumpiness A positive numeric value controlling the magnitude of random jumps.
#'   Higher values create larger perturbations. Default is 1.0.
#' @param inplace A logical value indicating whether to modify \code{x} in place (\code{TRUE})
#'   or return a new vector (\code{FALSE}). Default is \code{TRUE}.
#'
#' @return 
#' If \code{inplace = TRUE}, returns \code{NULL} and modifies \code{x} directly.
#' If \code{inplace = FALSE}, returns a new numeric vector with scrambled values.
#'
#' @examples
#' \dontrun{
#' library(dqrng)
#' dqset.seed(42)
#' 
#' # Create sample trajectory data
#' x <- c(0.1, 0.2, 0.3, 0.5, 0.6, 0.7)  # Two trajectories
#' pid <- c(TRUE, FALSE, FALSE, TRUE, FALSE, FALSE)  # Trajectory starts
#' 
#' # Scramble without modifying original
#' scrambled <- fscramble_trajectories(x, pid, jumpiness = 0.5, inplace = FALSE)
#' print(scrambled)
#' 
#' # Scramble in place
#' original_x <- x
#' fscramble_trajectories(x, pid, jumpiness = 1.0, inplace = TRUE)
#' print(x)  # x is now modified
#' 
#' # Use with data.table for multiple trajectories
#' library(data.table)
#' dt <- data.table(
#'   id = rep(1:3, each = 4),
#'   time = rep(1:4, 3),
#'   value = runif(12)
#' )
#' setkey(dt, id, time)
#' dt[, pid := time == 1]  # Mark trajectory starts
#' dt[, scrambled := fscramble_trajectories(value, pid, 
#'                                         jumpiness = 0.8, 
#'                                         inplace = FALSE)]
#' }
#'
#' @seealso
#' \code{\link[dqrng]{dqset.seed}}, \code{\link[dqrng]{dqRNGkind}}
#'
#' @author Chris Kypridemos
#' @export
fscramble_trajectories <- function(x, pid, jumpiness = 1.0, inplace = TRUE) {
    .Call(`_CKutils_fscramble_trajectories`, x, pid, jumpiness, inplace)
}

#' Shift Values by ID Groups
#' 
#' High-performance implementations for shifting/lagging values within groups 
#' defined by ID variables. These functions are optimized for panel data and 
#' time series analysis where values need to be shifted within groups while 
#' preserving group boundaries.
#' 
#' @param x Vector of values to be shifted. Can be numeric, integer, logical, or character.
#' @param lag Integer specifying the lag amount. Positive values create standard lags 
#'   (shift values forward in time), negative values create leads (shift values 
#'   backward in time).
#' @param replace Replacement value for positions that cannot be filled due to 
#'   shifting. For logical vectors, this should be a logical vector with one element.
#' @param id Integer vector of group identifiers. Must be the same length as x. 
#'   Should be sorted for optimal performance. Values are only shifted within 
#'   the same ID group.
#' 
#' @details
#' These functions implement efficient group-aware shifting operations commonly 
#' needed in panel data analysis. Key features include:
#' 
#' \itemize{
#'   \item \strong{Group preservation}: Values are never shifted across different ID groups
#'   \item \strong{Boundary handling}: Positions at group boundaries are filled with replacement values
#'   \item \strong{Bidirectional shifting}: Supports both lags (positive) and leads (negative)
#'   \item \strong{Type preservation}: Maintains original data types and attributes (e.g., factor levels)
#'   \item \strong{High performance}: Optimized C++ implementation with minimal memory allocation
#' }
#' 
#' For positive lag values:
#' \itemize{
#'   \item Values are shifted forward (standard lag operation)
#'   \item First `lag` positions in each group are filled with replacement value
#'   \item `x[i]` becomes `x[i-lag]` if `id[i] == id[i-lag]`, otherwise replacement value
#' }
#' 
#' For negative lag values (leads):
#' \itemize{
#'   \item Values are shifted backward (lead operation) 
#'   \item Last `abs(lag)` positions in each group are filled with replacement value
#'   \item `x[i]` becomes `x[i+abs(lag)]` if `id[i] == id[i+abs(lag)]`, otherwise replacement value
#' }
#' 
#' @return Vector of the same type and length as input `x`, with values shifted 
#'   according to the specified lag and group structure.
#' 
#' @examples
#' # Example data with two groups
#' id <- c(1, 1, 1, 2, 2, 2)
#' values <- c(10, 20, 30, 40, 50, 60)
#' 
#' # Lag by 1 (shift forward)
#' shift_bypidNum(values, lag = 1, replace = NA_real_, id = id)
#' # Result: [NA, 10, 20, NA, 40, 50]
#' 
#' # Lead by 1 (shift backward) 
#' shift_bypidNum(values, lag = -1, replace = NA_real_, id = id)
#' # Result: [20, 30, NA, 50, 60, NA]
#' 
#' # Integer data with factor preservation
#' factors <- factor(c("A", "B", "C", "A", "B", "C"))
#' factors_int <- as.integer(factors)
#' result <- shift_bypidInt(factors_int, lag = 1, replace = NA_integer_, id = id)
#' # Maintains factor attributes
#' 
#' # Logical data
#' logical_vals <- c(TRUE, FALSE, TRUE, FALSE, TRUE, FALSE)
#' shift_bypidBool(logical_vals, lag = 1, replace = FALSE, id = id)
#' 
#' # Character data
#' char_vals <- c("a", "b", "c", "d", "e", "f")
#' shift_bypidStr(char_vals, lag = 1, replace = "missing", id = id)
#' 
#' @seealso 
#' \code{\link[data.table]{shift}} for data.table's shift function,
#' \code{\link[dplyr]{lag}} and \code{\link[dplyr]{lead}} for dplyr alternatives.
#' 
#' @name shift_bypid
#' @rdname shift_bypid
NULL

#' Shift Numeric Values by ID Groups
#' 
#' @description
#' Efficiently shifts numeric values within groups defined by ID variables.
#' Optimized for panel data and time series analysis.
#' 
#' @param x Numeric vector of values to be shifted.
#' @param lag Integer specifying the lag amount. Positive values create standard lags 
#'   (shift values forward in time), negative values create leads (shift values 
#'   backward in time).
#' @param replace Numeric replacement value for positions that cannot be filled.
#' @param id Integer vector of group identifiers. Must be the same length as x. 
#'   Should be sorted for optimal performance. Values are only shifted within 
#'   the same ID group.
#' 
#' @return Numeric vector of the same length as input, with values shifted 
#'   according to the specified lag and group structure.
#' 
#' @export
#' @rdname shift_bypid
shift_bypidNum <- function(x, lag, replace, id) {
    .Call(`_CKutils_shift_bypidNum`, x, lag, replace, id)
}

#' Shift Integer Values by ID Groups
#' 
#' @description
#' Efficiently shifts integer values within groups defined by ID variables.
#' Preserves factor attributes when present, making it suitable for categorical data.
#' 
#' @param x Integer vector of values to be shifted. Factor attributes are preserved.
#' @param lag Integer specifying the lag amount. Positive values create standard lags 
#'   (shift values forward in time), negative values create leads (shift values 
#'   backward in time).
#' @param replace Integer replacement value for positions that cannot be filled.
#' @param id Integer vector of group identifiers. Must be the same length as x. 
#'   Should be sorted for optimal performance. Values are only shifted within 
#'   the same ID group.
#' 
#' @details
#' This function automatically detects and preserves factor attributes including
#' levels and class information. This makes it particularly useful for shifting
#' categorical variables that have been converted to integers.
#' 
#' @return Integer vector of the same length as input, with values shifted 
#'   according to the specified lag and group structure. Factor attributes 
#'   are preserved if present in the input.
#' 
#' @export
#' @rdname shift_bypid
shift_bypidInt <- function(x, lag, replace, id) {
    .Call(`_CKutils_shift_bypidInt`, x, lag, replace, id)
}

#' Shift Logical Values by ID Groups
#' 
#' @description
#' Efficiently shifts logical (boolean) values within groups defined by ID variables.
#' Designed for binary indicators and flag variables in panel data.
#' 
#' @param x Logical vector of values to be shifted.
#' @param lag Integer specifying the lag amount. Positive values create standard lags 
#'   (shift values forward in time), negative values create leads (shift values 
#'   backward in time).
#' @param replace Logical vector with one element specifying the replacement value 
#'   for positions that cannot be filled.
#' @param id Integer vector of group identifiers. Must be the same length as x. 
#'   Should be sorted for optimal performance. Values are only shifted within 
#'   the same ID group.
#' 
#' @details
#' The replacement parameter must be a logical vector (even with just one element)
#' to maintain type consistency. This is particularly useful for shifting binary
#' indicators, treatment flags, or event occurrence variables in longitudinal data.
#' 
#' @return Logical vector of the same length as input, with values shifted 
#'   according to the specified lag and group structure.
#' 
#' @export
#' @rdname shift_bypid
shift_bypidBool <- function(x, lag, replace, id) {
    .Call(`_CKutils_shift_bypidBool`, x, lag, replace, id)
}

#' Shift Character Values by ID Groups
#' 
#' @description
#' Efficiently shifts character (string) values within groups defined by ID variables.
#' Ideal for text data, labels, and categorical variables in panel data analysis.
#' 
#' @param x Character vector of values to be shifted.
#' @param lag Integer specifying the lag amount. Positive values create standard lags 
#'   (shift values forward in time), negative values create leads (shift values 
#'   backward in time).
#' @param replace String replacement value for positions that cannot be filled.
#' @param id Integer vector of group identifiers. Must be the same length as x. 
#'   Should be sorted for optimal performance. Values are only shifted within 
#'   the same ID group.
#' 
#' @details
#' This function handles character data efficiently by converting the replacement
#' value to the appropriate Rcpp::String type internally. It's particularly useful
#' for shifting categorical variables, labels, or any text-based data in 
#' longitudinal datasets.
#' 
#' @return Character vector of the same length as input, with values shifted 
#'   according to the specified lag and group structure.
#' 
#' @export
#' @rdname shift_bypid
shift_bypidStr <- function(x, lag, replace, id) {
    .Call(`_CKutils_shift_bypidStr`, x, lag, replace, id)
}

