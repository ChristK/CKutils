# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

tableRcpp <- function(x) {
    .Call(`_CKutils_tableRcpp`, x)
}

counts <- function(x) {
    .Call(`_CKutils_counts`, x)
}

#' Box-Cox Power Exponential Distribution (BCPEo) - Density Function
#'
#' Density function for the Box-Cox Power Exponential distribution with log link for mu,
#' optimised for SIMD vectorisation and unique parameter values.
#'
#' @param x vector of (non-negative) quantiles.
#' @param mu vector of (positive) location parameters.
#' @param sigma vector of (positive) scale parameters.
#' @param nu vector of shape parameters.
#' @param tau vector of (positive) shape parameters.
#' @param log_ logical; if TRUE, densities are returned on the log scale.
#'
#' @details
#' The Box-Cox Power Exponential (BCPEo) distribution is a four-parameter continuous
#' distribution defined on the positive real line. The BCPEo variant uses a log link
#' for the location parameter mu.
#'
#' The probability density function is given by:
#' \deqn{f(x|\mu,\sigma,\nu,\tau) = \frac{1}{\sigma x^{\nu}} \frac{f_T(z)}{F_T(1/(\sigma|\nu|))}}
#' where \eqn{z = (x^{\nu} - 1)/(\nu\sigma)} when \eqn{\nu \neq 0} and 
#' \eqn{z = \log(x)/\sigma} when \eqn{\nu = 0}, and \eqn{f_T} and \eqn{F_T} are 
#' the density and distribution functions of a specific T distribution.
#'
#' This implementation is optimised for cases where tau values are rarely repeated,
#' using SIMD vectorisation and per-element computation without caching.
#'
#' @return A numeric vector of densities.
#'
#' @references
#' Rigby, R. A. and Stasinopoulos, D. M. (2003) Flexible regression smoothing 
#' using GAMLSS. Applied Statistics, 52, 229-237.
#'
#' Stasinopoulos, D. M., Rigby, R. A., Heller, G. Z., Voudouris, V., and 
#' De Bastiani, F. (2017) Flexible Regression and Smoothing: Using GAMLSS in R,
#' Chapman and Hall/CRC.
#'
#' @note
#' This implementation is based on the gamlss.dist package dBCPEo function
#' but optimised for performance with unique parameter values and SIMD vectorisation.
#'
#' @examples
#' # Basic usage
#' x <- c(1, 2, 3, 4, 5)
#' mu <- c(2, 2, 2, 2, 2)
#' sigma <- c(0.5, 0.5, 0.5, 0.5, 0.5)
#' nu <- c(1, 1, 1, 1, 1)
#' tau <- c(2, 2, 2, 2, 2)
#' 
#' # Calculate densities
#' fdBCPEo(x, mu, sigma, nu, tau)
#' 
#' # Log densities
#' fdBCPEo(x, mu, sigma, nu, tau, log_ = TRUE)
#'
#' @seealso \code{\link{fpBCPEo}}, \code{\link{fqBCPEo}}
#' @export
fdBCPEo <- function(x, mu, sigma, nu, tau, log_ = FALSE) {
    .Call(`_CKutils_fdBCPEo`, x, mu, sigma, nu, tau, log_)
}

#' Box-Cox Power Exponential Distribution (BCPEo) - Distribution Function
#'
#' Distribution function for the Box-Cox Power Exponential distribution with log link for mu,
#' optimised for SIMD vectorisation and unique parameter values.
#'
#' @param q vector of (non-negative) quantiles.
#' @param mu vector of (positive) location parameters.
#' @param sigma vector of (positive) scale parameters.
#' @param nu vector of shape parameters.
#' @param tau vector of (positive) shape parameters.
#' @param lower_tail logical; if TRUE (default), probabilities are P(X ≤ x), 
#'        otherwise P(X > x).
#' @param log_p logical; if TRUE, probabilities p are given as log(p).
#'
#' @details
#' The Box-Cox Power Exponential (BCPEo) distribution is a four-parameter continuous
#' distribution defined on the positive real line. This function computes the
#' cumulative distribution function (CDF).
#'
#' The cumulative distribution function is given by:
#' \deqn{F(x|\mu,\sigma,\nu,\tau) = \frac{F_T(z) - F_T(-1/(\sigma|\nu|))}{F_T(1/(\sigma|\nu|))}}
#' where \eqn{z = (x^{\nu} - 1)/(\nu\sigma)} when \eqn{\nu \neq 0} and 
#' \eqn{z = \log(x)/\sigma} when \eqn{\nu = 0}, and \eqn{F_T} is the 
#' distribution function of a specific T distribution.
#'
#' This implementation is optimised for cases where tau values are rarely repeated,
#' using SIMD vectorisation and per-element computation without caching.
#'
#' @return A numeric vector of probabilities.
#'
#' @references
#' Rigby, R. A. and Stasinopoulos, D. M. (2003) Flexible regression smoothing 
#' using GAMLSS. Applied Statistics, 52, 229-237.
#'
#' Stasinopoulos, D. M., Rigby, R. A., Heller, G. Z., Voudouris, V., and 
#' De Bastiani, F. (2017) Flexible Regression and Smoothing: Using GAMLSS in R,
#' Chapman and Hall/CRC.
#'
#' @note
#' This implementation is based on the gamlss.dist package pBCPEo function
#' but optimised for performance with unique parameter values and SIMD vectorisation.
#'
#' @examples
#' # Basic usage
#' q <- c(1, 2, 3, 4, 5)
#' mu <- c(2, 2, 2, 2, 2)
#' sigma <- c(0.5, 0.5, 0.5, 0.5, 0.5)
#' nu <- c(1, 1, 1, 1, 1)
#' tau <- c(2, 2, 2, 2, 2)
#' 
#' # Calculate probabilities
#' fpBCPEo(q, mu, sigma, nu, tau)
#' 
#' # Upper tail probabilities
#' fpBCPEo(q, mu, sigma, nu, tau, lower_tail = FALSE)
#' 
#' # Log probabilities
#' fpBCPEo(q, mu, sigma, nu, tau, log_p = TRUE)
#'
#' @seealso \code{\link{fdBCPEo}}, \code{\link{fqBCPEo}}
#' pBCPEo distribution function
#' @export
fpBCPEo <- function(q, mu, sigma, nu, tau, lower_tail = TRUE, log_p = FALSE) {
    .Call(`_CKutils_fpBCPEo`, q, mu, sigma, nu, tau, lower_tail, log_p)
}

#' Box-Cox Power Exponential Distribution (BCPEo) - Quantile Function
#'
#' Quantile function for the Box-Cox Power Exponential distribution with log link for mu,
#' optimised for SIMD vectorisation and unique parameter values.
#'
#' @param p vector of probabilities (must be between 0 and 1).
#' @param mu vector of (positive) location parameters.
#' @param sigma vector of (positive) scale parameters.
#' @param nu vector of shape parameters.
#' @param tau vector of (positive) shape parameters.
#' @param lower_tail logical; if TRUE (default), probabilities are P(X ≤ x), 
#'        otherwise P(X > x).
#' @param log_p logical; if TRUE, probabilities p are given as log(p).
#'
#' @details
#' The Box-Cox Power Exponential (BCPEo) distribution is a four-parameter continuous
#' distribution defined on the positive real line. This function computes the
#' quantile function (inverse CDF).
#'
#' The quantile function involves solving:
#' \deqn{F(x|\mu,\sigma,\nu,\tau) = p}
#' where F is the cumulative distribution function. The solution is obtained by
#' first computing the quantile z_a from the underlying T distribution, then
#' transforming back to the original scale.
#'
#' When \eqn{\nu = 0}: \eqn{x = \mu \exp(\sigma z_a)}
#' When \eqn{\nu \neq 0}: \eqn{x = \mu (\nu\sigma z_a + 1)^{1/\nu}}
#'
#' This implementation is optimised for cases where tau values are rarely repeated,
#' using SIMD vectorisation and per-element computation without caching.
#'
#' @return A numeric vector of quantiles.
#'
#' @references
#' Rigby, R. A. and Stasinopoulos, D. M. (2003) Flexible regression smoothing 
#' using GAMLSS. Applied Statistics, 52, 229-237.
#'
#' Stasinopoulos, D. M., Rigby, R. A., Heller, G. Z., Voudouris, V., and 
#' De Bastiani, F. (2017) Flexible Regression and Smoothing: Using GAMLSS in R,
#' Chapman and Hall/CRC.
#'
#' @note
#' This implementation is based on the gamlss.dist package qBCPEo function
#' but optimised for performance with unique parameter values and SIMD vectorisation.
#'
#' @examples
#' # Basic usage
#' p <- c(0.1, 0.25, 0.5, 0.75, 0.9)
#' mu <- c(2, 2, 2, 2, 2)
#' sigma <- c(0.5, 0.5, 0.5, 0.5, 0.5)
#' nu <- c(1, 1, 1, 1, 1)
#' tau <- c(2, 2, 2, 2, 2)
#' 
#' # Calculate quantiles
#' fqBCPEo(p, mu, sigma, nu, tau)
#' 
#' # Upper tail quantiles
#' fqBCPEo(p, mu, sigma, nu, tau, lower_tail = FALSE)
#' 
#' # Log probabilities
#' log_p <- log(p)
#' fqBCPEo(log_p, mu, sigma, nu, tau, log_p = TRUE)
#'
#' @seealso \code{\link{fdBCPEo}}, \code{\link{fpBCPEo}}
#' qBCPEo quantile function
#' @export
fqBCPEo <- function(p, mu, sigma, nu, tau, lower_tail = TRUE, log_p = FALSE) {
    .Call(`_CKutils_fqBCPEo`, p, mu, sigma, nu, tau, lower_tail, log_p)
}

#' Box-Cox t (BCT) Distribution Functions
#'
#' Optimized implementations of density, distribution function, and quantile function
#' for the Box-Cox t distribution. These functions are numerically equivalent to
#' \code{gamlss.dist::dBCT}, \code{gamlss.dist::pBCT}, and \code{gamlss.dist::qBCT}
#' but with improved performance through SIMD optimization and defensive programming.
#'
#' @param x,q vector of quantiles. Must be non-negative.
#' @param p vector of probabilities. Must be in (0,1).
#' @param mu vector of location parameters. Must be positive. Note that mu is the
#'   median of the distribution.
#' @param sigma vector of scale parameters. Must be positive. For moderate nu > 0
#'   and moderate or large tau, sigma*sqrt(tau/(tau-2)) approximates the coefficient
#'   of variation.
#' @param nu vector of shape parameters. Controls the skewness of the distribution.
#'   Can be any real number.
#' @param tau vector of degrees of freedom parameters. Must be positive. Controls
#'   the kurtosis of the distribution.
#' @param log_,log_p logical; if TRUE, probabilities p are given as log(p)
#' @param lower_tail logical; if TRUE (default), probabilities are P[X ≤ x],
#'   otherwise P[X > x]
#'
#' @details
#' The Box-Cox t distribution is a four-parameter continuous distribution that
#' extends the Box-Cox normal distribution by replacing the normal kernel with
#' a t-distribution kernel. This provides additional flexibility for modelling
#' heavy-tailed data.
#'
#' The probability density function is given by:
#' \deqn{f(y|\mu,\sigma,\nu,\tau) = \frac{1}{y\sigma} \cdot \frac{\Gamma((\tau+1)/2)}{\Gamma(1/2)\Gamma(\tau/2)\tau^{1/2}} \cdot \left(1+\frac{z^2}{\tau}\right)^{-(\tau+1)/2}}
#'
#' where:
#' \itemize{
#'   \item If \eqn{\nu \neq 0}: \eqn{z = \frac{(y/\mu)^\nu - 1}{\nu \sigma}}
#'   \item If \eqn{\nu = 0}: \eqn{z = \frac{\log(y/\mu)}{\sigma}}
#' }
#'
#' The distribution is truncated to ensure y > 0, with appropriate normalization.
#'
#' When tau is very large (> 1e6), these implementations automatically switch to
#' a normal approximation for improved numerical stability and performance.
#'
#' @note
#' These optimised implementations include:
#' \itemize{
#'   \item SIMD vectorisation hints for modern compilers
#'   \item Precomputed mathematical constants
#'   \item Efficient input validation
#'   \item Robust handling of edge cases and extreme parameter values
#'   \item Memory-safe operations (no input mutation)
#' }
#'
#' Performance benchmarks show 1.4x average speedup over gamlss.dist, with
#' quantile functions achieving up to 2x speedup.
#'
#' @return
#' \code{fdBCT} gives the density, \code{fpBCT} gives the distribution function,
#' and \code{fqBCT} gives the quantile function.
#'
#' @references
#' Rigby, R.A. and Stasinopoulos, D.M. (2006). Using the Box-Cox t distribution
#' in GAMLSS to model skewness and kurtosis. Statistical Modelling, 6(3), 200.
#' \doi{10.1191/1471082X06st122oa}
#'
#' Rigby, R.A., Stasinopoulos, D.M., Heller, G.Z., and De Bastiani, F. (2019).
#' Distributions for modelling location, scale, and shape: Using GAMLSS in R.
#' Chapman and Hall/CRC. \doi{10.1201/9780429298547}
#'
#' Stasinopoulos, D.M. and Rigby, R.A. (2007). Generalized additive models for
#' location scale and shape (GAMLSS) in R. Journal of Statistical Software,
#' 23(7). \doi{10.18637/jss.v023.i07}
#'
#' @examples
#' # Basic usage - single values
#' fdBCT(2, mu = 1, sigma = 0.5, nu = 0.3, tau = 5)
#' fpBCT(2, mu = 1, sigma = 0.5, nu = 0.3, tau = 5)
#' fqBCT(0.5, mu = 1, sigma = 0.5, nu = 0.3, tau = 5)
#'
#' # Vectorized operations
#' x <- c(0.5, 1.0, 2.0, 3.0)
#' mu <- c(1.0, 1.2, 1.5, 1.8)
#' fdBCT(x, mu = mu, sigma = 0.5, nu = 0.3, tau = 5)
#'
#' # Log densities
#' fdBCT(x, mu = mu, sigma = 0.5, nu = 0.3, tau = 5, log_ = TRUE)
#'
#' # Upper tail probabilities
#' fpBCT(x, mu = mu, sigma = 0.5, nu = 0.3, tau = 5, lower_tail = FALSE)
#'
#' # Different parameter combinations
#' # Symmetric case (nu = 0)
#' fdBCT(c(1, 2, 3), mu = 2, sigma = 0.3, nu = 0, tau = 4)
#'
#' # Heavy-tailed case (small tau)
#' fdBCT(c(1, 2, 3), mu = 2, sigma = 0.3, nu = 0.5, tau = 2.1)
#'
#' # Light-tailed case (large tau, approaches normal)
#' fdBCT(c(1, 2, 3), mu = 2, sigma = 0.3, nu = 0.5, tau = 100)
#'
#' \dontrun{
#' # Comparison with gamlss.dist (requires gamlss.dist package)
#' library(gamlss.dist)
#' x <- c(1, 2, 3)
#' mu <- 2
#' sigma <- 0.5
#' nu <- 0.3
#' tau <- 5
#'
#' # Results should be numerically identical
#' all.equal(fdBCT(x, mu, sigma, nu, tau), dBCT(x, mu, sigma, nu, tau))
#' all.equal(fpBCT(x, mu, sigma, nu, tau), pBCT(x, mu, sigma, nu, tau))
#' all.equal(fqBCT(c(0.2, 0.5, 0.8), mu, sigma, nu, tau),
#'           qBCT(c(0.2, 0.5, 0.8), mu, sigma, nu, tau))
#'
#' # Performance comparison
#' library(microbenchmark)
#' microbenchmark(
#'   CKutils = fdBCT(x, mu, sigma, nu, tau),
#'   gamlss = dBCT(x, mu, sigma, nu, tau),
#'   times = 100
#' )
#' }
#'
#' @seealso
#' \code{\link{fpBCT}}, \code{\link{fqBCT}}.
#'
#' For the original implementations: \code{\link[gamlss.dist]{dBCT}},
#' \code{\link[gamlss.dist]{pBCT}}, \code{\link[gamlss.dist]{qBCT}}.
#'
#' For related distributions: \code{\link[gamlss.dist]{BCPE}},
#' \code{\link[gamlss.dist]{BCCG}}.
#'
#' @export
fdBCT <- function(x, mu, sigma, nu, tau, log_ = FALSE) {
    .Call(`_CKutils_fdBCT`, x, mu, sigma, nu, tau, log_)
}

#' Box-Cox t (BCT) Cumulative Distribution Function
#'
#' @description
#' Optimized implementation of the cumulative distribution function for the
#' Box-Cox t distribution. Numerically equivalent to \code{gamlss.dist::pBCT}
#' but with improved performance.
#'
#' @details
#' Computes P[X ≤ q] for the Box-Cox t distribution. The CDF involves
#' normalization to account for the y > 0 truncation of the distribution.
#'
#' For computational efficiency, this implementation uses:
#' \itemize{
#'   \item Vectorized t-distribution CDF calculations
#'   \item Efficient parameter transformation and caching
#'   \item Robust handling of boundary cases
#' }
#'
#' @return Vector of probabilities corresponding to the input quantiles.
#'
#' @examples
#' # Basic CDF evaluation
#' fpBCT(c(1, 2, 3), mu = 2, sigma = 0.5, nu = 0.3, tau = 5)
#'
#' # Upper tail probabilities
#' fpBCT(c(1, 2, 3), mu = 2, sigma = 0.5, nu = 0.3, tau = 5,
#'       lower_tail = FALSE)
#'
#' # Log probabilities
#' fpBCT(c(1, 2, 3), mu = 2, sigma = 0.5, nu = 0.3, tau = 5,
#'       log_p = TRUE)
#'
#' @rdname fdBCT
#' @export
fpBCT <- function(q, mu, sigma, nu, tau, lower_tail = TRUE, log_p = FALSE) {
    .Call(`_CKutils_fpBCT`, q, mu, sigma, nu, tau, lower_tail, log_p)
}

#' Box-Cox t (BCT) Quantile Function
#'
#' @description
#' Optimized implementation of the quantile function for the Box-Cox t distribution.
#' Numerically equivalent to \code{gamlss.dist::qBCT} but with significantly
#' improved performance (typically 2x faster).
#'
#' @details
#' Computes the inverse cumulative distribution function (quantiles) for the
#' Box-Cox t distribution. This function shows the largest performance improvement
#' over the gamlss.dist implementation due to optimised t-distribution quantile
#' calculations and efficient parameter transformations.
#'
#' The quantile calculation involves:
#' \itemize{
#'   \item Probability transformation accounting for distribution truncation
#'   \item t-distribution quantile computation using optimised R math library calls
#'   \item Inverse Box-Cox transformation to original scale
#'   \item Robust handling of boundary conditions and parameter edge cases
#' }
#'
#' Input probabilities are automatically cloned to ensure memory safety and
#' prevent unexpected side effects.
#'
#' @return Vector of quantiles corresponding to the input probabilities.
#'
#' @examples
#' # Basic quantile calculation
#' fqBCT(c(0.1, 0.5, 0.9), mu = 2, sigma = 0.5, nu = 0.3, tau = 5)
#'
#' # Median (50th percentile)
#' fqBCT(0.5, mu = 2, sigma = 0.5, nu = 0.3, tau = 5)  # Should equal mu
#'
#' # Extreme quantiles
#' fqBCT(c(0.001, 0.999), mu = 2, sigma = 0.5, nu = 0.3, tau = 5)
#'
#' # Upper tail quantiles
#' fqBCT(c(0.1, 0.5, 0.9), mu = 2, sigma = 0.5, nu = 0.3, tau = 5,
#'       lower_tail = FALSE)
#'
#' # Log probability scale
#' fqBCT(log(c(0.1, 0.5, 0.9)), mu = 2, sigma = 0.5, nu = 0.3, tau = 5,
#'       log_p = TRUE)
#'
#' @rdname fdBCT
#' @export
fqBCT <- function(p, mu, sigma, nu, tau, lower_tail = TRUE, log_p = FALSE) {
    .Call(`_CKutils_fqBCT`, p, mu, sigma, nu, tau, lower_tail, log_p)
}

#' Beta Negative Binomial Distribution Density
#'
#' Probability density function for the Beta Negative Binomial (BNB) distribution
#' with parameters mu (mean), sigma (dispersion), and nu (shape).
#'
#' @param x vector of (non-negative integer) quantiles.
#' @param mu vector of positive means.
#' @param sigma vector of positive dispersion parameters.
#' @param nu vector of positive shape parameters.
#' @param log logical; if TRUE, probabilities p are given as log(p).
#'
#' @details
#' The probability mass function of the BNB distribution is:
#' \deqn{f(y|\mu,\sigma,\nu) = \frac{\Gamma(y+1/\nu)\mathrm{B}(y+(\mu\nu)/\sigma, 1/\sigma+1/\nu+1)}{\Gamma(y+1)\Gamma(1/\nu)\mathrm{B}((\mu\nu)/\sigma, 1/\sigma+1)}}
#' for \eqn{y = 0, 1, 2, \ldots}, \eqn{\mu > 0}, \eqn{\sigma > 0}, and \eqn{\nu > 0}.
#'
#' @return A numeric vector of density values.
#' 
#' @references
#' Rigby, R. A., Stasinopoulos, D. M., Heller, G. Z., and De Bastiani, F. (2019) 
#' Distributions for modelling location, scale, and shape: Using GAMLSS in R, 
#' Chapman and Hall/CRC.
#'
#' @examples
#' # Single values
#' fdBNB(c(0,1,2,3), mu=2, sigma=1, nu=1)
#' 
#' # Vector inputs with recycling
#' fdBNB(0:5, mu=c(1,2), sigma=0.5, nu=c(1,1.5,2))
#'
#' @export
fdBNB <- function(x, mu, sigma, nu, log = FALSE) {
    .Call(`_CKutils_fdBNB`, x, mu, sigma, nu, log)
}

#' Beta Negative Binomial Distribution Function
#'
#' Cumulative distribution function for the Beta Negative Binomial (BNB) distribution
#' with parameters mu (mean), sigma (dispersion), and nu (shape).
#'
#' @param q vector of (non-negative integer) quantiles.
#' @param mu vector of positive means.
#' @param sigma vector of positive dispersion parameters.
#' @param nu vector of positive shape parameters.
#' @param lower_tail logical; if TRUE (default), probabilities are P[X <= x], otherwise, P[X > x].
#' @param log_p logical; if TRUE, probabilities p are given as log(p).
#'
#' @details
#' The cumulative distribution function is computed by summing the probability mass
#' function from 0 to q.
#'
#' @return A numeric vector of cumulative probabilities.
#' 
#' @references
#' Rigby, R. A., Stasinopoulos, D. M., Heller, G. Z., and De Bastiani, F. (2019) 
#' Distributions for modelling location, scale, and shape: Using GAMLSS in R, 
#' Chapman and Hall/CRC.
#'
#' @examples
#' # Single values
#' fpBNB(c(0,1,2,3), mu=2, sigma=1, nu=1)
#' 
#' # Vector inputs with recycling
#' fpBNB(0:5, mu=c(1,2), sigma=0.5, nu=c(1,1.5,2))
#'
#' @export
fpBNB <- function(q, mu, sigma, nu, lower_tail = TRUE, log_p = FALSE) {
    .Call(`_CKutils_fpBNB`, q, mu, sigma, nu, lower_tail, log_p)
}

#' Beta Negative Binomial Quantile Function
#'
#' Quantile function for the Beta Negative Binomial (BNB) distribution
#' with parameters mu (mean), sigma (dispersion), and nu (shape).
#'
#' @param p vector of probabilities.
#' @param mu vector of positive means.
#' @param sigma vector of positive dispersion parameters.
#' @param nu vector of positive shape parameters.
#' @param lower_tail logical; if TRUE (default), probabilities are P[X <= x], otherwise, P[X > x].
#' @param log_p logical; if TRUE, probabilities p are given as log(p).
#'
#' @details
#' The quantile function uses a fast divide-and-conquer algorithm to find
#' the quantiles efficiently.
#'
#' @return An integer vector of quantiles.
#' 
#' @references
#' Rigby, R. A., Stasinopoulos, D. M., Heller, G. Z., and De Bastiani, F. (2019) 
#' Distributions for modelling location, scale, and shape: Using GAMLSS in R, 
#' Chapman and Hall/CRC.
#'
#' @examples
#' # Single values
#' fqBNB(c(0.1, 0.5, 0.9), mu=2, sigma=1, nu=1)
#' 
#' # Vector inputs with recycling
#' fqBNB(c(0.25, 0.75), mu=c(1,2), sigma=0.5, nu=c(1,1.5,2))
#'
#' @export
fqBNB <- function(p, mu, sigma, nu, lower_tail = TRUE, log_p = FALSE) {
    .Call(`_CKutils_fqBNB`, p, mu, sigma, nu, lower_tail, log_p)
}

#' The Delaporte Distribution - Density Function
#'
#' Density function for the Delaporte distribution with parameters mu, sigma and nu.
#' The Delaporte distribution is a discrete probability distribution that can be 
#' expressed as a compound Poisson distribution where the intensity parameter follows
#' a Gamma distribution.
#'
#' @param x vector of (non-negative integer) quantiles
#' @param mu vector of positive means
#' @param sigma vector of positive dispersion parameters
#' @param nu vector of parameters between 0 and 1
#' @param log_ logical; if TRUE, probabilities p are given as log(p)
#'
#' @details
#' The Delaporte distribution has probability mass function:
#' \deqn{P(X = x) = e^{-\mu\nu} \frac{\Gamma(x + 1/\sigma)}{\Gamma(x + 1)\Gamma(1/\sigma)} \left(\frac{\mu\sigma(1-\nu)}{1 + \mu\sigma(1-\nu)}\right)^x \left(\frac{1}{1 + \mu\sigma(1-\nu)}\right)^{1/\sigma}}
#' 
#' for x = 0, 1, 2, ..., mu > 0, sigma > 0, and 0 < nu < 1.
#' 
#' The mean is mu and the variance is mu + mu^2 * sigma * (1 - nu).
#' 
#' This implementation is based on the algorithms from the gamlss.dist package
#' by Rigby, R. A. and Stasinopoulos D. M., with optimizations for performance
#' including SIMD support and efficient parameter recycling.
#'
#' @return
#' \code{fdDEL} gives the density
#'
#' @note
#' This function is optimised for performance with chunked processing and
#' efficient memory access patterns.
#'
#' @references
#' Rigby, R. A. and Stasinopoulos D. M. (2005). Generalized additive models for 
#' location, scale and shape,(with discussion), Appl. Statist., 54, part 3, pp 507-554.
#' 
#' Rigby, R. A., Stasinopoulos, D. M., Heller, G. Z., and De Bastiani, F. (2019)
#' Distributions for modelling location, scale, and shape: Using GAMLSS in R, Chapman and Hall/CRC.
#' 
#' Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location 
#' scale and shape (GAMLSS) in R. Journal of Statistical Software, Vol. 23, Issue 7, Dec 2007.
#'
#' @author Chris Kypridemos (optimised implementation), based on original work by 
#' Bob Rigby and Mikis Stasinopoulos from gamlss.dist package
#'
#' @seealso \code{\link{fpDEL}}, \code{\link{fqDEL}}
#'
#' @examples
#' # Calculate density for single values
#' fdDEL(0:5, mu = 2, sigma = 1, nu = 0.5)
#' 
#' # Calculate log density
#' fdDEL(0:5, mu = 2, sigma = 1, nu = 0.5, log = TRUE)
#' 
#' # Parameter recycling
#' fdDEL(c(0, 1, 2), mu = c(1, 2, 3), sigma = c(0.5, 1, 1.5), nu = c(0.3, 0.5, 0.7))
#'
#' @export
fdDEL <- function(x, mu, sigma, nu, log_ = FALSE) {
    .Call(`_CKutils_fdDEL`, x, mu, sigma, nu, log_)
}

#' The Delaporte Distribution - Cumulative Distribution Function
#'
#' Distribution function for the Delaporte distribution with parameters mu, sigma and nu.
#' Computes the cumulative distribution function (CDF) of the Delaporte distribution.
#'
#' @param q vector of (non-negative integer) quantiles
#' @param mu vector of positive means
#' @param sigma vector of positive dispersion parameters
#' @param nu vector of parameters between 0 and 1
#' @param lower_tail logical; if TRUE (default), probabilities are P[X <= x], otherwise, P[X > x]
#' @param log_p logical; if TRUE, probabilities p are given as log(p)
#'
#' @details
#' The cumulative distribution function is computed as the sum of the probability
#' mass function from 0 to q. For computational efficiency, this implementation
#' employs chunked processing with SIMD optimizations when available and is
#' optimised for scenarios with varying parameter combinations.
#' 
#' When sigma is very small (< 1e-04), the distribution approaches a Poisson
#' distribution with parameter mu, and the function switches to using the
#' more efficient Poisson CDF computation.
#' 
#' This implementation is based on the algorithms from the gamlss.dist package
#' by Rigby, R. A. and Stasinopoulos D. M., with significant performance
#' optimizations including vectorized transformations and SIMD support for
#' large datasets with diverse parameter sets.
#'
#' @return
#' \code{fpDEL} gives the cumulative distribution function
#'
#' @note
#' This function is optimised for scenarios where parameters vary between
#' computations (e.g., random parameters). For applications with repeated
#' parameter combinations, consider implementing application-specific caching.
#'
#' @references
#' Rigby, R. A. and Stasinopoulos D. M. (2005). Generalized additive models for 
#' location, scale and shape,(with discussion), Appl. Statist., 54, part 3, pp 507-554.
#' 
#' Rigby, R. A., Stasinopoulos, D. M., Heller, G. Z., and De Bastiani, F. (2019)
#' Distributions for modelling location, scale, and shape: Using GAMLSS in R, Chapman and Hall/CRC.
#' 
#' Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location 
#' scale and shape (GAMLSS) in R. Journal of Statistical Software, Vol. 23, Issue 7, Dec 2007.
#'
#' @author Chris Kypridemos (optimised implementation), based on original work by 
#' Bob Rigby and Mikis Stasinopoulos from gamlss.dist package
#'
#' @seealso \code{\link{fdDEL}}, \code{\link{fqDEL}}
#'
#' @examples
#' # Calculate CDF for single values
#' fpDEL(0:5, mu = 2, sigma = 1, nu = 0.5)
#' 
#' # Calculate upper tail probabilities
#' fpDEL(0:5, mu = 2, sigma = 1, nu = 0.5, lower_tail = FALSE)
#' 
#' # Calculate log probabilities
#' fpDEL(0:5, mu = 2, sigma = 1, nu = 0.5, log_p = TRUE)
#' 
#' # Parameter recycling
#' fpDEL(c(0, 1, 2), mu = c(1, 2, 3), sigma = c(0.5, 1, 1.5), nu = c(0.3, 0.5, 0.7))
#'
#' @export
fpDEL <- function(q, mu, sigma, nu, lower_tail = TRUE, log_p = FALSE) {
    .Call(`_CKutils_fpDEL`, q, mu, sigma, nu, lower_tail, log_p)
}

#' Quantile Function for the Delaporte Distribution
#'
#' Computes quantiles of the Delaporte distribution, a compound distribution of
#' Poisson and shifted negative binomial.
#'
#' @param p Vector of probabilities.
#' @param mu Vector of mu (location/mean) parameters (positive).
#' @param sigma Vector of sigma (scale) parameters (positive).
#' @param nu Vector of nu (shape) parameters (positive).
#' @param lower_tail Logical; if TRUE (default), probabilities are P[X ≤ x],
#'   otherwise P[X > x].
#' @param log_p Logical; if TRUE, probabilities p are given as log(p).
#'
#' @return Vector of quantiles corresponding to the given probabilities.
#'
#' @details
#' The Delaporte distribution is a three-parameter discrete distribution
#' defined as the convolution of a Poisson distribution with mean \code{mu}
#' and a shifted negative binomial distribution with parameters related to
#' \code{sigma} and \code{nu}.
#'
#' This implementation uses an optimised binary search algorithm with
#' SIMD acceleration where available, and includes intelligent caching
#' of intermediate CDF calculations for improved performance with repeated
#' quantile computations.
#'
#' Parameter recycling is performed automatically - all parameter vectors
#' are recycled to the length of the longest vector.
#'
#' @section Parameter Validation:
#' - \code{p} must be in [0,1] for \code{log_p = FALSE}, or in (-Inf, 0] for \code{log_p = TRUE}
#' - \code{mu}, \code{sigma}, \code{nu} must all be positive
#' - Invalid parameters result in \code{NA} values in the output
#'
#' @note
#' This function is based on the Delaporte distribution implementation from
#' the \pkg{gamlss.dist} package by Mikis Stasinopoulos, Robert Rigby,
#' Calliope Akantziliotou, Vlasios Voudouris, and Fernanda De Bastiani.
#' The original gamlss.dist implementation is acknowledged with gratitude.
#'
#' @references
#' Rigby, R. A. and Stasinopoulos D. M. (2005). Generalized additive models
#' for location, scale and shape,(with discussion), \emph{Appl. Statist.}, \bold{54}, part 3, pp 507-554.
#'
#' Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
#' \emph{Flexible Regression and Smoothing: Using GAMLSS in R}, Chapman and Hall/CRC.
#'
#' Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location
#' scale and shape (GAMLSS) in R. \emph{Journal of Statistical Software}, Vol. \bold{23}, Issue 7, Dec 2007.
#'
#' @author Christos Kypraios [aut, cre], based on gamlss.dist by Mikis Stasinopoulos,
#' Robert Rigby, Calliope Akantziliotou, Vlasios Voudouris, Fernanda De Bastiani
#'
#' @seealso \code{\link{fdDEL}}, \code{\link{fpDEL}}
#'
#' @examples
#' # Basic quantile computation
#' fqDEL(c(0.25, 0.5, 0.75), mu=5, sigma=1, nu=0.2)
#'
#' # With parameter recycling
#' fqDEL(0.5, mu=c(1,5,10), sigma=c(0.5,1,2), nu=c(0.1,0.2,0.9))
#'
#' # Using log probabilities
#' fqDEL(log(c(0.25, 0.5, 0.75)), mu=5, sigma=1, nu=0.2, log_p=TRUE)
#'
#' # Upper tail probabilities
#' fqDEL(c(0.25, 0.5, 0.75), mu=5, sigma=1, nu=0.2, lower_tail=FALSE)
#'
#' @export
fqDEL <- function(p, mu, sigma, nu, lower_tail = TRUE, log_p = FALSE) {
    .Call(`_CKutils_fqDEL`, p, mu, sigma, nu, lower_tail, log_p)
}

#' Get Normalizing Constant for DPO Distribution
#'
#' Computes the logarithm of the normalizing constant for the DPO distribution.
#' This is an internal function used by the DPO distribution functions.
#'
#' @param x vector of (non-negative integer) quantiles
#' @param mu vector of positive means
#' @param sigma vector of positive dispersion parameters
#'
#' @details
#' This function computes the logarithm of the normalizing constant required
#' for the DPO (Double Poisson) distribution. The computation follows the
#' algorithm from gamlss.dist but with optimizations for performance.
#'
#' @return Vector of log normalizing constants
#'
#' @note
#' This function is based on the DPO distribution implementation from
#' the \pkg{gamlss.dist} package by Mikis Stasinopoulos, Robert Rigby,
#' and colleagues. The original gamlss.dist implementation is acknowledged
#' with gratitude.
#'
#' @references
#' Rigby, R. A. and Stasinopoulos D. M. (2005). Generalized additive models for 
#' location, scale and shape,(with discussion), Appl. Statist., 54, part 3, pp 507-554.
#' 
#' Rigby, R. A., Stasinopoulos, D. M., Heller, G. Z., and De Bastiani, F. (2019)
#' Distributions for modelling location, scale, and shape: Using GAMLSS in R, Chapman and Hall/CRC.
#'
#' @author Chris Kypridemos (optimised implementation), based on original work by 
#' Bob Rigby and Mikis Stasinopoulos from gamlss.dist package
#'
#' @seealso \code{\link{fdDPO}}, \code{\link{fpDPO}}, \code{\link{fqDPO}}
#'
#' @export
fget_C <- function(x, mu, sigma) {
    .Call(`_CKutils_fget_C`, x, mu, sigma)
}

#' The DPO Distribution - Density Function
#'
#' Density function for the DPO (Double Poisson) distribution with parameters mu and sigma.
#' The DPO distribution is a discrete probability distribution that extends the
#' Poisson distribution by adding an additional dispersion parameter.
#'
#' @param x vector of (non-negative integer) quantiles
#' @param mu vector of positive means
#' @param sigma vector of positive dispersion parameters
#' @param log_ logical; if TRUE, probabilities p are given as log(p)
#'
#' @details
#' The DPO distribution has probability mass function with mean mu and 
#' dispersion controlled by sigma. When sigma = 1, it reduces to the Poisson
#' distribution. Values of sigma > 1 indicate overdispersion, while sigma < 1
#' indicates underdispersion.
#' 
#' This implementation is based on the algorithms from the gamlss.dist package
#' by Rigby, R. A. and Stasinopoulos D. M., with optimizations for performance
#' including SIMD support and improved caching.
#'
#' @return
#' \code{fdDPO} gives the density
#'
#' @note
#' This function is optimised for performance with chunked processing and
#' prefetching for better cache utilization.
#'
#' @references
#' Rigby, R. A. and Stasinopoulos D. M. (2005). Generalized additive models for 
#' location, scale and shape,(with discussion), Appl. Statist., 54, part 3, pp 507-554.
#' 
#' Rigby, R. A., Stasinopoulos, D. M., Heller, G. Z., and De Bastiani, F. (2019)
#' Distributions for modelling location, scale, and shape: Using GAMLSS in R, Chapman and Hall/CRC.
#' 
#' Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location 
#' scale and shape (GAMLSS) in R. Journal of Statistical Software, Vol. 23, Issue 7, Dec 2007.
#'
#' @author Chris Kypridemos (optimised implementation), based on original work by 
#' Bob Rigby and Mikis Stasinopoulos from gamlss.dist package
#'
#' @seealso \code{\link{fpDPO}}, \code{\link{fqDPO}}
#'
#' @examples
#' # Calculate density for single values
#' fdDPO(0:5, mu = 2, sigma = 1)
#' 
#' # Calculate log density
#' fdDPO(0:5, mu = 2, sigma = 1, log_ = TRUE)
#' 
#' # Parameter recycling
#' fdDPO(c(0, 1, 2), mu = c(1, 2, 3), sigma = c(0.5, 1, 1.5))
#'
#' @export
fdDPO <- function(x, mu, sigma, log_ = FALSE) {
    .Call(`_CKutils_fdDPO`, x, mu, sigma, log_)
}

#' The DPO Distribution - Cumulative Distribution Function
#'
#' Distribution function for the DPO (Double Poisson) distribution with parameters mu and sigma.
#' Computes the cumulative distribution function (CDF) of the DPO distribution.
#'
#' @param q vector of (non-negative integer) quantiles
#' @param mu vector of positive means
#' @param sigma vector of positive dispersion parameters
#' @param lower_tail logical; if TRUE (default), probabilities are P[X <= x], otherwise, P[X > x]
#' @param log_p logical; if TRUE, probabilities p are given as log(p)
#'
#' @details
#' The cumulative distribution function is computed using the normalizing constants
#' approach from gamlss.dist. For computational efficiency, this implementation
#' employs chunked processing with SIMD optimizations when available and is
#' optimised for scenarios with varying parameter combinations.
#' 
#' This implementation is based on the algorithms from the gamlss.dist package
#' by Rigby, R. A. and Stasinopoulos D. M., with significant performance
#' optimizations including vectorized transformations and SIMD support for
#' large datasets with diverse parameter sets.
#'
#' @return
#' \code{fpDPO} gives the cumulative distribution function
#'
#' @note
#' This function is optimised for scenarios where parameters vary between
#' computations (e.g., random parameters). For applications with repeated
#' parameter combinations, consider implementing application-specific caching.
#'
#' @references
#' Rigby, R. A. and Stasinopoulos D. M. (2005). Generalized additive models for 
#' location, scale and shape,(with discussion), Appl. Statist., 54, part 3, pp 507-554.
#' 
#' Rigby, R. A., Stasinopoulos, D. M., Heller, G. Z., and De Bastiani, F. (2019)
#' Distributions for modelling location, scale, and shape: Using GAMLSS in R, Chapman and Hall/CRC.
#' 
#' Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location 
#' scale and shape (GAMLSS) in R. Journal of Statistical Software, Vol. 23, Issue 7, Dec 2007.
#'
#' @author Chris Kypridemos (optimised implementation), based on original work by 
#' Bob Rigby and Mikis Stasinopoulos from gamlss.dist package
#'
#' @seealso \code{\link{fdDPO}}, \code{\link{fqDPO}}
#'
#' @examples
#' # Calculate CDF for single values
#' fpDPO(0:5, mu = 2, sigma = 1)
#' 
#' # Calculate upper tail probabilities
#' fpDPO(0:5, mu = 2, sigma = 1, lower_tail = FALSE)
#' 
#' # Calculate log probabilities
#' fpDPO(0:5, mu = 2, sigma = 1, log_p = TRUE)
#' 
#' # Parameter recycling
#' fpDPO(c(0, 1, 2), mu = c(1, 2, 3), sigma = c(0.5, 1, 1.5))
#'
#' @export
fpDPO <- function(q, mu, sigma, lower_tail = TRUE, log_p = FALSE) {
    .Call(`_CKutils_fpDPO`, q, mu, sigma, lower_tail, log_p)
}

#' Quantile Function for the DPO Distribution
#'
#' Computes quantiles of the DPO (Double Poisson) distribution, a discrete
#' distribution that extends the Poisson distribution with a dispersion parameter.
#'
#' @param p Vector of probabilities.
#' @param mu Vector of mu (location/mean) parameters (positive).
#' @param sigma Vector of sigma (dispersion) parameters (positive).
#' @param lower_tail Logical; if TRUE (default), probabilities are P[X ≤ x],
#'   otherwise P[X > x].
#' @param log_p Logical; if TRUE, probabilities p are given as log(p).
#' @param max_value Maximum value to search for quantiles (for performance tuning).
#'
#' @return Vector of quantiles corresponding to the given probabilities.
#'
#' @details
#' The DPO distribution is a two-parameter discrete distribution that reduces
#' to the Poisson distribution when sigma = 1. This implementation uses an
#' optimised search algorithm with SIMD acceleration where available, and
#' includes intelligent caching of intermediate CDF calculations for improved
#' performance with repeated quantile computations.
#'
#' Parameter recycling is performed automatically - all parameter vectors
#' are recycled to the length of the longest vector.
#'
#' @section Parameter Validation:
#' - \code{p} must be in [0,1] for \code{log_p = FALSE}, or in (-Inf, 0] for \code{log_p = TRUE}
#' - \code{mu}, \code{sigma} must both be positive
#' - Invalid parameters result in \code{NA} values in the output
#'
#' @note
#' This function is based on the DPO distribution implementation from
#' the \pkg{gamlss.dist} package by Mikis Stasinopoulos, Robert Rigby,
#' and colleagues. The original gamlss.dist implementation is acknowledged
#' with gratitude.
#'
#' @references
#' Rigby, R. A. and Stasinopoulos D. M. (2005). Generalized additive models
#' for location, scale and shape,(with discussion), \emph{Appl. Statist.}, \bold{54}, part 3, pp 507-554.
#'
#' Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017)
#' \emph{Flexible Regression and Smoothing: Using GAMLSS in R}, Chapman and Hall/CRC.
#'
#' Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location
#' scale and shape (GAMLSS) in R. \emph{Journal of Statistical Software}, Vol. \bold{23}, Issue 7, Dec 2007.
#'
#' @author Chris Kypridemos [aut, cre], based on gamlss.dist by Mikis Stasinopoulos,
#' Robert Rigby, and colleagues
#'
#' @seealso \code{\link{fdDPO}}, \code{\link{fpDPO}}
#'
#' @examples
#' # Basic quantile computation
#' fqDPO(c(0.25, 0.5, 0.75), mu=5, sigma=1)
#'
#' # With parameter recycling
#' fqDPO(0.5, mu=c(1,5,10), sigma=c(0.5,1,2))
#'
#' # Using log probabilities
#' fqDPO(log(c(0.25, 0.5, 0.75)), mu=5, sigma=1, log_p=TRUE)
#'
#' # Upper tail probabilities
#' fqDPO(c(0.25, 0.5, 0.75), mu=5, sigma=1, lower_tail=FALSE)
#'
#' @export
fqDPO <- function(p, mu, sigma, lower_tail = TRUE, log_p = FALSE, max_value = 0L) {
    .Call(`_CKutils_fqDPO`, p, mu, sigma, lower_tail, log_p, max_value)
}

#' Multinomial Distribution with 4 Categories - Density Function
#'
#' Density function for the multinomial distribution with 4 categories,
#' optimised for performance with SIMD vectorisation and parameter recycling.
#'
#' @param x vector of (integer) quantiles. Must be 1, 2, 3, or 4.
#' @param mu vector of (positive) parameters for category 1.
#' @param sigma vector of (positive) parameters for category 2.
#' @param nu vector of (positive) parameters for category 3.
#' @param log_ logical; if TRUE, densities are returned on the log scale.
#'
#' @details
#' The multinomial distribution with 4 categories (MN4) is a discrete distribution
#' defined on the integers {1, 2, 3, 4}. The probability mass function is:
#' \deqn{P(X = k) = \frac{\theta_k}{1 + \mu + \sigma + \nu}}
#' where \eqn{\theta_1 = \mu}, \eqn{\theta_2 = \sigma}, \eqn{\theta_3 = \nu},
#' and \eqn{\theta_4 = 1}.
#'
#' Parameters are recycled to the length of the longest vector following R's
#' standard recycling rules.
#'
#' @return A numeric vector of densities.
#'
#' @references
#' Rigby, R. A. and Stasinopoulos, D. M. (2005). Generalized additive models
#' for location, scale and shape. Applied Statistics, 54, 507-554.
#'
#' @note
#' This implementation is based on the gamlss.dist package dMN4 function
#' but optimised for performance with SIMD vectorisation and parameter recycling.
#'
#' @examples
#' # Basic usage
#' x <- c(1, 2, 3, 4)
#' mu <- c(1, 1, 1, 1)
#' sigma <- c(1, 1, 1, 1)
#' nu <- c(1, 1, 1, 1)
#' 
#' # Calculate densities
#' fdMN4(x, mu, sigma, nu)
#' 
#' # Log densities
#' fdMN4(x, mu, sigma, nu, log_ = TRUE)
#' 
#' # Parameter recycling
#' fdMN4(c(1, 2, 3, 4), mu = 2, sigma = 1, nu = 0.5)
#'
#' @seealso \code{\link{fpMN4}}, \code{\link{fqMN4}}
#' @export
fdMN4 <- function(x, mu, sigma, nu, log_ = FALSE) {
    .Call(`_CKutils_fdMN4`, x, mu, sigma, nu, log_)
}

#' Multinomial Distribution with 4 Categories - Distribution Function
#'
#' Distribution function for the multinomial distribution with 4 categories,
#' optimised for performance with SIMD vectorisation and parameter recycling.
#'
#' @param q vector of (integer) quantiles. Must be 1, 2, 3, or 4.
#' @param mu vector of (positive) parameters for category 1.
#' @param sigma vector of (positive) parameters for category 2.
#' @param nu vector of (positive) parameters for category 3.
#' @param lower_tail logical; if TRUE (default), probabilities are P(X ≤ q),
#'        otherwise P(X > q).
#' @param log_p logical; if TRUE, probabilities are returned on the log scale.
#'
#' @details
#' The cumulative distribution function of the multinomial distribution with
#' 4 categories is:
#' \deqn{P(X \leq k) = \frac{\sum_{i=1}^{k} \theta_i}{1 + \mu + \sigma + \nu}}
#' where \eqn{\theta_1 = \mu}, \eqn{\theta_2 = \sigma}, \eqn{\theta_3 = \nu},
#' and \eqn{\theta_4 = 1}.
#'
#' Parameters are recycled to the length of the longest vector following R's
#' standard recycling rules.
#'
#' @return A numeric vector of probabilities.
#'
#' @references
#' Rigby, R. A. and Stasinopoulos, D. M. (2005). Generalized additive models
#' for location, scale and shape. Applied Statistics, 54, 507-554.
#'
#' @note
#' This implementation is based on the gamlss.dist package pMN4 function
#' but optimised for performance with SIMD vectorisation and parameter recycling.
#'
#' @examples
#' # Basic usage
#' q <- c(1, 2, 3, 4)
#' mu <- c(1, 1, 1, 1)
#' sigma <- c(1, 1, 1, 1)
#' nu <- c(1, 1, 1, 1)
#' 
#' # Calculate probabilities
#' fpMN4(q, mu, sigma, nu)
#' 
#' # Upper tail probabilities
#' fpMN4(q, mu, sigma, nu, lower_tail = FALSE)
#' 
#' # Log probabilities
#' fpMN4(q, mu, sigma, nu, log_p = TRUE)
#' 
#' # Parameter recycling
#' fpMN4(c(1, 2, 3, 4), mu = 2, sigma = 1, nu = 0.5)
#'
#' @seealso \code{\link{fdMN4}}, \code{\link{fqMN4}}
#' @export
fpMN4 <- function(q, mu, sigma, nu, lower_tail = TRUE, log_p = FALSE) {
    .Call(`_CKutils_fpMN4`, q, mu, sigma, nu, lower_tail, log_p)
}

#' Multinomial Distribution with 4 Categories - Quantile Function
#'
#' Quantile function for the multinomial distribution with 4 categories,
#' optimised for performance with SIMD vectorisation and parameter recycling.
#'
#' @param p vector of probabilities (must be between 0 and 1).
#' @param mu vector of (positive) parameters for category 1.
#' @param sigma vector of (positive) parameters for category 2.
#' @param nu vector of (positive) parameters for category 3.
#' @param lower_tail logical; if TRUE (default), probabilities are P(X ≤ q),
#'        otherwise P(X > q).
#' @param log_p logical; if TRUE, probabilities p are given as log(p).
#'
#' @details
#' The quantile function returns the smallest integer k such that
#' \deqn{P(X \leq k) \geq p}
#' The quantiles are computed by comparing p with the cumulative probabilities
#' of the multinomial distribution.
#'
#' Parameters are recycled to the length of the longest vector following R's
#' standard recycling rules.
#'
#' @return An integer vector of quantiles.
#'
#' @references
#' Rigby, R. A. and Stasinopoulos, D. M. (2005). Generalized additive models
#' for location, scale and shape. Applied Statistics, 54, 507-554.
#'
#' @note
#' This implementation is based on the gamlss.dist package qMN4 function
#' but optimised for performance with SIMD vectorisation and parameter recycling.
#'
#' @examples
#' # Basic usage
#' p <- c(0.1, 0.3, 0.6, 0.9)
#' mu <- c(1, 1, 1, 1)
#' sigma <- c(1, 1, 1, 1)
#' nu <- c(1, 1, 1, 1)
#' 
#' # Calculate quantiles
#' fqMN4(p, mu, sigma, nu)
#' 
#' # Upper tail quantiles
#' fqMN4(p, mu, sigma, nu, lower_tail = FALSE)
#' 
#' # Log probabilities
#' fqMN4(log(p), mu, sigma, nu, log_p = TRUE)
#' 
#' # Parameter recycling
#' fqMN4(c(0.1, 0.3, 0.6, 0.9), mu = 2, sigma = 1, nu = 0.5)
#'
#' @seealso \code{\link{fdMN4}}, \code{\link{fpMN4}}
#' @export
fqMN4 <- function(p, mu, sigma, nu, lower_tail = TRUE, log_p = FALSE) {
    .Call(`_CKutils_fqMN4`, p, mu, sigma, nu, lower_tail, log_p)
}

#' Multinomial Distribution with 4 Categories - Random Generation
#'
#' Random generation for the multinomial distribution with 4 categories,
#' optimised for performance with SIMD vectorisation and parameter recycling.
#'
#' @param n number of random values to generate.
#' @param mu vector of (positive) parameters for category 1.
#' @param sigma vector of (positive) parameters for category 2.
#' @param nu vector of (positive) parameters for category 3.
#'
#' @details
#' Random values are generated using the quantile function method:
#' generate uniform random variables and apply the quantile function.
#'
#' Parameters are recycled to the length n following R's standard recycling rules.
#'
#' @return An integer vector of random values.
#'
#' @references
#' Rigby, R. A. and Stasinopoulos, D. M. (2005). Generalized additive models
#' for location, scale and shape. Applied Statistics, 54, 507-554.
#'
#' @note
#' This implementation is based on the gamlss.dist package rMN4 function
#' but optimised for performance with SIMD vectorisation and parameter recycling.
#'
#' @examples
#' # Basic usage
#' frMN4(10, mu = 1, sigma = 1, nu = 1)
#' 
#' # With different parameters
#' frMN4(10, mu = 2, sigma = 1, nu = 0.5)
#' 
#' # Parameter recycling
#' frMN4(10, mu = c(1, 2), sigma = c(1, 0.5), nu = c(1, 2))
#'
#' @seealso \code{\link{fdMN4}}, \code{\link{fpMN4}}, \code{\link{fqMN4}}
#' @export
frMN4 <- function(n, mu, sigma, nu) {
    .Call(`_CKutils_frMN4`, n, mu, sigma, nu)
}

#' Negative Binomial Type I Distribution Density
#'
#' Probability density function for the Negative Binomial type I (NBI) distribution
#' with parameters mu (mean) and sigma (dispersion).
#'
#' @param x vector of (non-negative integer) quantiles.
#' @param mu vector of positive means.
#' @param sigma vector of positive dispersion parameters.
#' @param log_p logical; if TRUE, probabilities p are given as log(p).
#'
#' @details
#' The probability mass function of the NBI distribution is:
#' \deqn{f(y|\mu,\sigma) = \frac{\Gamma(y+1/\sigma)}{\Gamma(y+1)\Gamma(1/\sigma)} \left(\frac{1}{1+\mu\sigma}\right)^{1/\sigma} \left(\frac{\mu\sigma}{1+\mu\sigma}\right)^y}
#' for \eqn{y = 0, 1, 2, \ldots}, \eqn{\mu > 0}, and \eqn{\sigma > 0}.
#'
#' For \eqn{\sigma < 0.0001}, the distribution reduces to the Poisson distribution.
#'
#' @return A numeric vector of density values.
#' 
#' @references
#' Rigby, R. A., Stasinopoulos, D. M., Heller, G. Z., and De Bastiani, F. (2019) 
#' Distributions for modelling location, scale, and shape: Using GAMLSS in R, 
#' Chapman and Hall/CRC.
#'
#' @examples
#' # Single values
#' fdNBI(c(0,1,2,3), mu=2, sigma=1)
#' 
#' # Vector inputs with recycling
#' fdNBI(0:5, mu=c(1,2), sigma=0.5)
#'
#' @export
fdNBI <- function(x, mu, sigma, log_p = FALSE) {
    .Call(`_CKutils_fdNBI`, x, mu, sigma, log_p)
}

#' Negative Binomial Type I Distribution Cumulative Distribution Function
#'
#' Cumulative distribution function for the Negative Binomial type I (NBI) distribution
#' with parameters mu (mean) and sigma (dispersion).
#'
#' @param q vector of quantiles.
#' @param mu vector of positive means.
#' @param sigma vector of positive dispersion parameters.
#' @param lower_tail logical; if TRUE (default), probabilities are P[X ≤ x],
#'   otherwise, P[X > x].
#' @param log_p logical; if TRUE, probabilities p are given as log(p).
#'
#' @details
#' The cumulative distribution function of the NBI distribution is:
#' \deqn{F(y|\mu,\sigma) = \sum_{i=0}^{y} f(i|\mu,\sigma)}
#' where \eqn{f(i|\mu,\sigma)} is the probability mass function.
#'
#' For \eqn{\sigma < 0.0001}, the distribution reduces to the Poisson distribution.
#'
#' @return A numeric vector of cumulative probabilities.
#' 
#' @references
#' Rigby, R. A., Stasinopoulos, D. M., Heller, G. Z., and De Bastiani, F. (2019) 
#' Distributions for modelling location, scale, and shape: Using GAMLSS in R, 
#' Chapman and Hall/CRC.
#'
#' @examples
#' # Single values
#' fpNBI(c(0,1,2,3), mu=2, sigma=1)
#' 
#' # Vector inputs with recycling
#' fpNBI(0:5, mu=c(1,2), sigma=0.5)
#'
#' @export
fpNBI <- function(q, mu, sigma, lower_tail = TRUE, log_p = FALSE) {
    .Call(`_CKutils_fpNBI`, q, mu, sigma, lower_tail, log_p)
}

#' Negative Binomial Type I Distribution Quantile Function
#'
#' Quantile function for the Negative Binomial type I (NBI) distribution
#' with parameters mu (mean) and sigma (dispersion).
#'
#' @param p vector of probabilities.
#' @param mu vector of positive means.
#' @param sigma vector of positive dispersion parameters.
#' @param lower_tail logical; if TRUE (default), probabilities are P[X ≤ x],
#'   otherwise, P[X > x].
#' @param log_p logical; if TRUE, probabilities p are given as log(p).
#'
#' @details
#' The quantile function returns the smallest integer \eqn{x} such that
#' \eqn{F(x) \geq p}, where \eqn{F} is the cumulative distribution function.
#'
#' For \eqn{\sigma < 0.0001}, the distribution reduces to the Poisson distribution.
#'
#' @return A numeric vector of quantiles.
#' 
#' @references
#' Rigby, R. A., Stasinopoulos, D. M., Heller, G. Z., and De Bastiani, F. (2019) 
#' Distributions for modelling location, scale, and shape: Using GAMLSS in R, 
#' Chapman and Hall/CRC.
#'
#' @examples
#' # Single values
#' fqNBI(c(0.1, 0.5, 0.9), mu=2, sigma=1)
#' 
#' # Vector inputs with recycling
#' fqNBI(c(0.25, 0.5, 0.75), mu=c(1,2), sigma=0.5)
#'
#' @export
fqNBI <- function(p, mu, sigma, lower_tail = TRUE, log_p = FALSE) {
    .Call(`_CKutils_fqNBI`, p, mu, sigma, lower_tail, log_p)
}

#' Negative Binomial Type I Distribution Random Generation
#'
#' Random generation for the Negative Binomial type I (NBI) distribution
#' with parameters mu (mean) and sigma (dispersion).
#'
#' @param n number of observations.
#' @param mu vector of positive means.
#' @param sigma vector of positive dispersion parameters.
#'
#' @details
#' Random variates are generated using the negative binomial distribution
#' with size parameter \eqn{1/\sigma} and mean parameter \eqn{\mu}.
#'
#' For \eqn{\sigma < 0.0001}, the distribution reduces to the Poisson distribution.
#'
#' @return A numeric vector of random variates.
#' 
#' @references
#' Rigby, R. A., Stasinopoulos, D. M., Heller, G. Z., and De Bastiani, F. (2019) 
#' Distributions for modelling location, scale, and shape: Using GAMLSS in R, 
#' Chapman and Hall/CRC.
#'
#' @examples
#' # Generate random variates
#' frNBI(10, mu=2, sigma=1)
#' 
#' # Vector inputs with recycling
#' frNBI(5, mu=c(1,2), sigma=0.5)
#'
#' @export
frNBI <- function(n, mu, sigma) {
    .Call(`_CKutils_frNBI`, n, mu, sigma)
}

#' Sichel Distribution Density
#'
#' Probability density function for the Sichel distribution with parameters 
#' mu (mean), sigma (dispersion), and nu (shape).
#'
#' @param x vector of (non-negative integer) quantiles.
#' @param mu vector of positive means.
#' @param sigma vector of positive dispersion parameters.
#' @param nu vector of shape parameters (real values).
#' @param log_p logical; if TRUE, probabilities p are given as log(p).
#'
#' @details
#' The probability mass function of the Sichel distribution is:
#' \deqn{f(y|\mu,\sigma,\nu)= \frac{(\mu/c)^y K_{y+\nu}(\alpha)}{y!(\alpha \sigma)^{y+\nu} K_\nu(\frac{1}{\sigma})}}
#' for \eqn{y=0,1,2,...}, \eqn{\mu>0}, \eqn{\sigma>0} and \eqn{-\infty<\nu<\infty}
#' where \eqn{\alpha^2= 1/\sigma^2 +2*\mu/\sigma}, 
#' \eqn{c=K_{\nu+1}(1/\sigma)/K_{\nu}(1/\sigma)}, and 
#' \eqn{K_{\lambda}(t)} is the modified Bessel function of the third kind.
#'
#' When \eqn{\sigma > 10000} and \eqn{\nu > 0}, the function uses the NBI 
#' approximation for numerical stability.
#'
#' @return A numeric vector of density values.
#' 
#' @references
#' Rigby, R. A., Stasinopoulos, D. M., Heller, G. Z., and De Bastiani, F. (2019) 
#' Distributions for modelling location, scale, and shape: Using GAMLSS in R, 
#' Chapman and Hall/CRC.
#' 
#' Stein, G. Z., Zucchini, W. and Juritz, J. M. (1987). Parameter
#' Estimation of the Sichel Distribution and its Multivariate Extension.
#' Journal of American Statistical Association, 82, 938-944.
#'
#' @examples
#' # Single values
#' fdSICHEL(c(0,1,2,3), mu=1, sigma=1, nu=-0.5)
#' 
#' # Vector inputs with recycling
#' fdSICHEL(0:5, mu=c(1,2), sigma=1, nu=-0.5)
#'
#' @export
fdSICHEL <- function(x, mu, sigma, nu, log_p = FALSE) {
    .Call(`_CKutils_fdSICHEL`, x, mu, sigma, nu, log_p)
}

#' Sichel Distribution Cumulative Distribution Function
#'
#' Distribution function for the Sichel distribution with parameters 
#' mu (mean), sigma (dispersion), and nu (shape).
#'
#' @param q vector of quantiles.
#' @param mu vector of positive means.
#' @param sigma vector of positive dispersion parameters.
#' @param nu vector of shape parameters (real values).
#' @param lower_tail logical; if TRUE (default), probabilities are P[X <= x],
#'   otherwise, P[X > x].
#' @param log_p logical; if TRUE, probabilities p are given as log(p).
#'
#' @details
#' The cumulative distribution function computes the probability that a 
#' Sichel random variable is less than or equal to q.
#'
#' @return A numeric vector of probabilities.
#' 
#' @references
#' Rigby, R. A., Stasinopoulos, D. M., Heller, G. Z., and De Bastiani, F. (2019) 
#' Distributions for modelling location, scale, and shape: Using GAMLSS in R, 
#' Chapman and Hall/CRC.
#'
#' @examples
#' # Single values
#' fpSICHEL(c(0,1,2,3), mu=1, sigma=1, nu=-0.5)
#' 
#' # Vector inputs with recycling
#' fpSICHEL(0:5, mu=c(1,2), sigma=1, nu=-0.5)
#'
#' @export
fpSICHEL <- function(q, mu, sigma, nu, lower_tail = TRUE, log_p = FALSE) {
    .Call(`_CKutils_fpSICHEL`, q, mu, sigma, nu, lower_tail, log_p)
}

#' Sichel Distribution Quantile Function
#'
#' Quantile function for the Sichel distribution with parameters 
#' mu (mean), sigma (dispersion), and nu (shape).
#'
#' @param p vector of probabilities.
#' @param mu vector of positive means.
#' @param sigma vector of positive dispersion parameters.
#' @param nu vector of shape parameters (real values).
#' @param lower_tail logical; if TRUE (default), probabilities are P[X <= x],
#'   otherwise, P[X > x].
#' @param log_p logical; if TRUE, probabilities p are given as log(p).
#'
#' @details
#' The quantile function uses a divide-and-conquer search algorithm to find
#' the smallest integer x such that P(X <= x) >= p.
#'
#' @return A numeric vector of quantiles.
#' 
#' @references
#' Rigby, R. A., Stasinopoulos, D. M., Heller, G. Z., and De Bastiani, F. (2019) 
#' Distributions for modelling location, scale, and shape: Using GAMLSS in R, 
#' Chapman and Hall/CRC.
#'
#' @examples
#' # Single values
#' fqSICHEL(c(0.1, 0.5, 0.9), mu=1, sigma=1, nu=-0.5)
#' 
#' # Vector inputs with recycling
#' fqSICHEL(c(0.25, 0.75), mu=c(1,2), sigma=1, nu=-0.5)
#'
#' @export
fqSICHEL <- function(p, mu, sigma, nu, lower_tail = TRUE, log_p = FALSE) {
    .Call(`_CKutils_fqSICHEL`, p, mu, sigma, nu, lower_tail, log_p)
}

#' Zero Adjusted Beta Negative Binomial Quantile Function
#'
#' Quantile function for the Zero Adjusted (Hurdle) Beta Negative Binomial (ZABNB) distribution
#' with parameters mu (mean), sigma (dispersion), nu (shape), and tau (hurdle probability).
#'
#' @param p vector of probabilities.
#' @param mu vector of positive means.
#' @param sigma vector of positive dispersion parameters.
#' @param nu vector of positive shape parameters.
#' @param tau vector of hurdle probabilities (0 < tau < 1).
#' @param lower_tail logical; if TRUE (default), probabilities are P[X <= x], otherwise, P[X > x].
#' @param log_p logical; if TRUE, probabilities p are given as log(p).
#'
#' @details
#' The zero adjusted (hurdle) beta negative binomial distribution has two parts:
#' a point mass at zero and a truncated BNB distribution for positive values.
#'
#' @return An integer vector of quantiles.
#' 
#' @references
#' Rigby, R. A., Stasinopoulos, D. M., Heller, G. Z., and De Bastiani, F. (2019) 
#' Distributions for modelling location, scale, and shape: Using GAMLSS in R, 
#' Chapman and Hall/CRC.
#'
#' @examples
#' # Single values
#' fqZABNB(c(0.1, 0.5, 0.9), mu=2, sigma=1, nu=1, tau=0.1)
#' 
#' # Vector inputs with recycling
#' fqZABNB(c(0.25, 0.75), mu=c(1,2), sigma=0.5, nu=c(1,1.5), tau=0.1)
#'
#' @export
fqZABNB <- function(p, mu, sigma, nu, tau, lower_tail = TRUE, log_p = FALSE) {
    .Call(`_CKutils_fqZABNB`, p, mu, sigma, nu, tau, lower_tail, log_p)
}

#' Zero-Altered Negative Binomial Type I Distribution Density
#'
#' Probability density function for the Zero-Altered Negative Binomial type I (ZANBI) 
#' distribution with parameters mu (mean), sigma (dispersion), and nu (zero-alteration probability).
#'
#' @param x vector of (non-negative integer) quantiles.
#' @param mu vector of positive means.
#' @param sigma vector of positive dispersion parameters.
#' @param nu vector of zero-alteration probabilities (0 < nu < 1).
#' @param log logical; if TRUE, probabilities p are given as log(p).
#'
#' @details
#' The Zero-Altered NBI distribution is a modification of the standard NBI distribution
#' where the probability at zero is altered. The probability mass function is:
#' \deqn{P(Y = 0) = \nu}
#' \deqn{P(Y = y) = (1-\nu) \frac{f_{NBI}(y|\mu,\sigma)}{1 - f_{NBI}(0|\mu,\sigma)} \quad \text{for } y > 0}
#' where \eqn{f_{NBI}} is the NBI probability mass function.
#'
#' @return A numeric vector of density values.
#' 
#' @references
#' Rigby, R. A., Stasinopoulos, D. M., Heller, G. Z., and De Bastiani, F. (2019) 
#' Distributions for modelling location, scale, and shape: Using GAMLSS in R, 
#' Chapman and Hall/CRC.
#'
#' @examples
#' # Single values
#' fdZANBI(c(0,1,2,3), mu=2, sigma=1, nu=0.1)
#' 
#' # Vector inputs with recycling
#' fdZANBI(0:5, mu=c(1,2), sigma=0.5, nu=0.1)
#'
#' @export
fdZANBI <- function(x, mu, sigma, nu, log = FALSE) {
    .Call(`_CKutils_fdZANBI`, x, mu, sigma, nu, log)
}

#' Zero-Altered Negative Binomial Type I Distribution CDF
#'
#' Cumulative distribution function for the Zero-Altered Negative Binomial type I (ZANBI)
#' distribution with parameters mu (mean), sigma (dispersion), and nu (zero-alteration probability).
#'
#' @param q vector of quantiles.
#' @param mu vector of positive means.
#' @param sigma vector of positive dispersion parameters.
#' @param nu vector of zero-alteration probabilities (0 < nu < 1).
#' @param lower.tail logical; if TRUE (default), probabilities are P[X ≤ x],
#'   otherwise, P[X > x].
#' @param log.p logical; if TRUE, probabilities p are given as log(p).
#'
#' @details
#' The cumulative distribution function for the Zero-Altered NBI distribution is:
#' \deqn{F(0) = \nu}
#' \deqn{F(q) = \nu + (1-\nu) \frac{F_{NBI}(q|\mu,\sigma) - F_{NBI}(0|\mu,\sigma)}{1 - F_{NBI}(0|\mu,\sigma)} \quad \text{for } q > 0}
#' where \eqn{F_{NBI}} is the NBI cumulative distribution function.
#'
#' @return A numeric vector of cumulative probabilities.
#' 
#' @references
#' Rigby, R. A., Stasinopoulos, D. M., Heller, G. Z., and De Bastiani, F. (2019) 
#' Distributions for modelling location, scale, and shape: Using GAMLSS in R, 
#' Chapman and Hall/CRC.
#'
#' @examples
#' # Single values
#' fpZANBI(c(0,1,2,3), mu=2, sigma=1, nu=0.1)
#' 
#' # Vector inputs with recycling
#' fpZANBI(0:5, mu=c(1,2), sigma=0.5, nu=0.1)
#'
#' @export
fpZANBI <- function(q, mu, sigma, nu, lower_tail = TRUE, log_p = FALSE) {
    .Call(`_CKutils_fpZANBI`, q, mu, sigma, nu, lower_tail, log_p)
}

#' Zero-Altered Negative Binomial Type I Distribution Quantile Function
#'
#' Quantile function for the Zero-Altered Negative Binomial type I (ZANBI)
#' distribution with parameters mu (mean), sigma (dispersion), and nu (zero-alteration probability).
#'
#' @param p vector of probabilities.
#' @param mu vector of positive means.
#' @param sigma vector of positive dispersion parameters.
#' @param nu vector of zero-alteration probabilities (0 < nu < 1).
#' @param lower.tail logical; if TRUE (default), probabilities are P[X ≤ x],
#'   otherwise, P[X > x].
#' @param log.p logical; if TRUE, probabilities p are given as log(p).
#'
#' @details
#' The quantile function returns the smallest integer \eqn{x} such that
#' \eqn{F(x) \geq p}, where \eqn{F} is the ZANBI cumulative distribution function.
#'
#' @return A numeric vector of quantiles.
#' 
#' @references
#' Rigby, R. A., Stasinopoulos, D. M., Heller, G. Z., and De Bastiani, F. (2019) 
#' Distributions for modelling location, scale, and shape: Using GAMLSS in R, 
#' Chapman and Hall/CRC.
#'
#' @examples
#' # Single values
#' fqZANBI(c(0.1, 0.5, 0.9), mu=2, sigma=1, nu=0.1)
#' 
#' # Vector inputs with recycling
#' fqZANBI(c(0.25, 0.5, 0.75), mu=c(1,2), sigma=0.5, nu=0.1)
#'
#' @export
fqZANBI <- function(p, mu, sigma, nu, lower_tail = TRUE, log_p = FALSE) {
    .Call(`_CKutils_fqZANBI`, p, mu, sigma, nu, lower_tail, log_p)
}

#' Zero-Altered Negative Binomial Type I Distribution Random Generation
#'
#' Random generation for the Zero-Altered Negative Binomial type I (ZANBI)
#' distribution with parameters mu (mean), sigma (dispersion), and nu (zero-alteration probability).
#'
#' @param n number of observations.
#' @param mu vector of positive means.
#' @param sigma vector of positive dispersion parameters.
#' @param nu vector of zero-alteration probabilities (0 < nu < 1).
#'
#' @details
#' Random variates are generated using a rejection approach: with probability \eqn{\nu}
#' the value is 0, and with probability \eqn{1-\nu} the value is drawn from the
#' standard NBI distribution truncated at zero (i.e., excluding zero).
#'
#' @return A numeric vector of random variates.
#' 
#' @references
#' Rigby, R. A., Stasinopoulos, D. M., Heller, G. Z., and De Bastiani, F. (2019) 
#' Distributions for modelling location, scale, and shape: Using GAMLSS in R, 
#' Chapman and Hall/CRC.
#'
#' @examples
#' # Generate random variates
#' frZANBI(10, mu=2, sigma=1, nu=0.1)
#' 
#' # Vector inputs with recycling
#' frZANBI(5, mu=c(1,2), sigma=0.5, nu=0.1)
#'
#' @export
frZANBI <- function(n, mu, sigma, nu) {
    .Call(`_CKutils_frZANBI`, n, mu, sigma, nu)
}

#' Zero Inflated Beta Negative Binomial Quantile Function
#'
#' Quantile function for the Zero Inflated Beta Negative Binomial (ZIBNB) distribution
#' with parameters mu (mean), sigma (dispersion), nu (shape), and tau (zero inflation).
#'
#' @param p vector of probabilities.
#' @param mu vector of positive means.
#' @param sigma vector of positive dispersion parameters.
#' @param nu vector of positive shape parameters.
#' @param tau vector of zero inflation probabilities (0 < tau < 1).
#' @param lower_tail logical; if TRUE (default), probabilities are P[X <= x], otherwise, P[X > x].
#' @param log_p logical; if TRUE, probabilities p are given as log(p).
#'
#' @details
#' The zero inflated beta negative binomial distribution allows for excess zeros
#' beyond what the BNB distribution would predict.
#'
#' @return An integer vector of quantiles.
#' 
#' @references
#' Rigby, R. A., Stasinopoulos, D. M., Heller, G. Z., and De Bastiani, F. (2019) 
#' Distributions for modelling location, scale, and shape: Using GAMLSS in R, 
#' Chapman and Hall/CRC.
#'
#' @examples
#' # Single values
#' fqZIBNB(c(0.1, 0.5, 0.9), mu=2, sigma=1, nu=1, tau=0.1)
#' 
#' # Vector inputs with recycling
#' fqZIBNB(c(0.25, 0.75), mu=c(1,2), sigma=0.5, nu=c(1,1.5), tau=0.1)
#'
#' @export
fqZIBNB <- function(p, mu, sigma, nu, tau, lower_tail = TRUE, log_p = FALSE) {
    .Call(`_CKutils_fqZIBNB`, p, mu, sigma, nu, tau, lower_tail, log_p)
}

#' Zero-Inflated Negative Binomial Type I Distribution Density
#'
#' Probability density function for the Zero-Inflated Negative Binomial type I (ZINBI) 
#' distribution with parameters mu (mean), sigma (dispersion), and nu (zero-inflation probability).
#'
#' @param x vector of (non-negative integer) quantiles.
#' @param mu vector of positive means.
#' @param sigma vector of positive dispersion parameters.
#' @param nu vector of zero-inflation probabilities (0 < nu < 1).
#' @param log logical; if TRUE, probabilities p are given as log(p).
#'
#' @details
#' The Zero-Inflated NBI distribution is a mixture of a degenerate distribution
#' at zero and a standard NBI distribution. The probability mass function is:
#' \deqn{P(Y = 0) = \nu + (1-\nu) f_{NBI}(0|\mu,\sigma)}
#' \deqn{P(Y = y) = (1-\nu) f_{NBI}(y|\mu,\sigma) \quad \text{for } y > 0}
#' where \eqn{f_{NBI}} is the NBI probability mass function.
#'
#' @return A numeric vector of density values.
#' 
#' @references
#' Rigby, R. A., Stasinopoulos, D. M., Heller, G. Z., and De Bastiani, F. (2019) 
#' Distributions for modelling location, scale, and shape: Using GAMLSS in R, 
#' Chapman and Hall/CRC.
#'
#' @examples
#' # Single values
#' fdZINBI(c(0,1,2,3), mu=2, sigma=1, nu=0.1)
#' 
#' # Vector inputs with recycling
#' fdZINBI(0:5, mu=c(1,2), sigma=0.5, nu=0.1)
#'
#' @export
fdZINBI <- function(x, mu, sigma, nu, log = FALSE) {
    .Call(`_CKutils_fdZINBI`, x, mu, sigma, nu, log)
}

#' Zero-Inflated Negative Binomial Type I Distribution CDF
#'
#' Cumulative distribution function for the Zero-Inflated Negative Binomial type I (ZINBI)
#' distribution with parameters mu (mean), sigma (dispersion), and nu (zero-inflation probability).
#'
#' @param q vector of quantiles.
#' @param mu vector of positive means.
#' @param sigma vector of positive dispersion parameters.
#' @param nu vector of zero-inflation probabilities (0 < nu < 1).
#' @param lower.tail logical; if TRUE (default), probabilities are P[X ≤ x],
#'   otherwise, P[X > x].
#' @param log.p logical; if TRUE, probabilities p are given as log(p).
#'
#' @details
#' The cumulative distribution function for the Zero-Inflated NBI distribution is:
#' \deqn{F(q) = \nu + (1-\nu) F_{NBI}(q|\mu,\sigma)}
#' where \eqn{F_{NBI}} is the NBI cumulative distribution function.
#'
#' @return A numeric vector of cumulative probabilities.
#' 
#' @references
#' Rigby, R. A., Stasinopoulos, D. M., Heller, G. Z., and De Bastiani, F. (2019) 
#' Distributions for modelling location, scale, and shape: Using GAMLSS in R, 
#' Chapman and Hall/CRC.
#'
#' @examples
#' # Single values
#' fpZINBI(c(0,1,2,3), mu=2, sigma=1, nu=0.1)
#' 
#' # Vector inputs with recycling
#' fpZINBI(0:5, mu=c(1,2), sigma=0.5, nu=0.1)
#'
#' @export
fpZINBI <- function(q, mu, sigma, nu, lower_tail = TRUE, log_p = FALSE) {
    .Call(`_CKutils_fpZINBI`, q, mu, sigma, nu, lower_tail, log_p)
}

#' Zero-Inflated Negative Binomial Type I Distribution Quantile Function
#'
#' Quantile function for the Zero-Inflated Negative Binomial type I (ZINBI)
#' distribution with parameters mu (mean), sigma (dispersion), and nu (zero-inflation probability).
#'
#' @param p vector of probabilities.
#' @param mu vector of positive means.
#' @param sigma vector of positive dispersion parameters.
#' @param nu vector of zero-inflation probabilities (0 < nu < 1).
#' @param lower.tail logical; if TRUE (default), probabilities are P[X ≤ x],
#'   otherwise, P[X > x].
#' @param log.p logical; if TRUE, probabilities p are given as log(p).
#'
#' @details
#' The quantile function returns the smallest integer \eqn{x} such that
#' \eqn{F(x) \geq p}, where \eqn{F} is the ZINBI cumulative distribution function.
#'
#' @return A numeric vector of quantiles.
#' 
#' @references
#' Rigby, R. A., Stasinopoulos, D. M., Heller, G. Z., and De Bastiani, F. (2019) 
#' Distributions for modelling location, scale, and shape: Using GAMLSS in R, 
#' Chapman and Hall/CRC.
#'
#' @examples
#' # Single values
#' fqZINBI(c(0.1, 0.5, 0.9), mu=2, sigma=1, nu=0.1)
#' 
#' # Vector inputs with recycling
#' fqZINBI(c(0.25, 0.5, 0.75), mu=c(1,2), sigma=0.5, nu=0.1)
#'
#' @export
fqZINBI <- function(p, mu, sigma, nu, lower_tail = TRUE, log_p = FALSE) {
    .Call(`_CKutils_fqZINBI`, p, mu, sigma, nu, lower_tail, log_p)
}

#' Zero-Inflated Negative Binomial Type I Distribution Random Generation
#'
#' Random generation for the Zero-Inflated Negative Binomial type I (ZINBI)
#' distribution with parameters mu (mean), sigma (dispersion), and nu (zero-inflation probability).
#'
#' @param n number of observations.
#' @param mu vector of positive means.
#' @param sigma vector of positive dispersion parameters.
#' @param nu vector of zero-inflation probabilities (0 < nu < 1).
#'
#' @details
#' Random variates are generated using a mixture approach: with probability \eqn{\nu}
#' the value is 0, and with probability \eqn{1-\nu} the value is drawn from the
#' standard NBI distribution.
#'
#' @return A numeric vector of random variates.
#' 
#' @references
#' Rigby, R. A., Stasinopoulos, D. M., Heller, G. Z., and De Bastiani, F. (2019) 
#' Distributions for modelling location, scale, and shape: Using GAMLSS in R, 
#' Chapman and Hall/CRC.
#'
#' @examples
#' # Generate random variates
#' frZINBI(10, mu=2, sigma=1, nu=0.1)
#' 
#' # Vector inputs with recycling
#' frZINBI(5, mu=c(1,2), sigma=0.5, nu=0.1)
#'
#' @export
frZINBI <- function(n, mu, sigma, nu) {
    .Call(`_CKutils_frZINBI`, n, mu, sigma, nu)
}

#' Zero-Inflated Sichel Distribution Quantile Function
#'
#' Quantile function for the zero-inflated Sichel distribution with parameters 
#' mu (mean), sigma (dispersion), nu (shape), and tau (zero-inflation).
#'
#' @param p vector of probabilities.
#' @param mu vector of positive means.
#' @param sigma vector of positive dispersion parameters.
#' @param nu vector of shape parameters (real values).
#' @param tau vector of zero-inflation parameters (0 < tau < 1).
#' @param lower_tail logical; if TRUE (default), probabilities are P[X <= x],
#'   otherwise, P[X > x].
#' @param log_p logical; if TRUE, probabilities p are given as log(p).
#'
#' @details
#' The zero-inflated Sichel distribution is a mixture of a point mass at zero 
#' and a (truncated at zero) Sichel distribution.
#'
#' @return A numeric vector of quantiles.
#' 
#' @references
#' Rigby, R. A., Stasinopoulos, D. M., Heller, G. Z., and De Bastiani, F. (2019) 
#' Distributions for modelling location, scale, and shape: Using GAMLSS in R, 
#' Chapman and Hall/CRC.
#'
#' @examples
#' # Vector inputs with recycling
#' fqZISICHEL(c(0.25, 0.75), mu=c(1,2), sigma=1, nu=-0.5, tau=0.1)
#'
#' @export
fqZISICHEL <- function(p, mu, sigma, nu, tau, lower_tail = TRUE, log_p = FALSE) {
    .Call(`_CKutils_fqZISICHEL`, p, mu, sigma, nu, tau, lower_tail, log_p)
}

#' Zero-Inflated Sichel Distribution Cumulative Distribution Function
#'
#' Distribution function for the zero-inflated Sichel distribution with parameters 
#' mu (mean), sigma (dispersion), nu (shape), and tau (zero-inflation).
#'
#' @param q vector of quantiles.
#' @param mu vector of positive means.
#' @param sigma vector of positive dispersion parameters.
#' @param nu vector of shape parameters (real values).
#' @param tau vector of zero-inflation parameters (0 < tau < 1).
#' @param lower_tail logical; if TRUE (default), probabilities are P[X <= x],
#'   otherwise, P[X > x].
#' @param log_p logical; if TRUE, probabilities p are given as log(p).
#'
#' @details
#' The zero-inflated Sichel distribution is a mixture of a point mass at zero 
#' and a (truncated at zero) Sichel distribution.
#'
#' @return A numeric vector of probabilities.
#' 
#' @references
#' Rigby, R. A., Stasinopoulos, D. M., Heller, G. Z., and De Bastiani, F. (2019) 
#' Distributions for modelling location, scale, and shape: Using GAMLSS in R, 
#' Chapman and Hall/CRC.
#'
#' @examples
#' # Vector inputs with recycling
#' fpZISICHEL(0:5, mu=c(1,2), sigma=1, nu=-0.5, tau=0.1)
#'
#' @export
fpZISICHEL <- function(q, mu, sigma, nu, tau, lower_tail = TRUE, log_p = FALSE) {
    .Call(`_CKutils_fpZISICHEL`, q, mu, sigma, nu, tau, lower_tail, log_p)
}

#' Convert Factor to Integer (C++ Version)
#'
#' This function converts a factor (an integer vector with a "levels" attribute)
#' to its underlying integer representation by stripping away the factor's levels and class attributes.
#' By default, the function does not modify the input by reference (a copy is made), but if `inplace`
#' is set to `true`, the function will modify the input directly.
#'
#' @param x A factor object.
#' @param inplace Logical flag indicating whether to modify the input in place (default: false).
#'
#' @return An integer vector containing the underlying integer codes without factor attributes.
#'
#' @export
fct_to_int_cpp <- function(x, inplace = FALSE) {
    .Call(`_CKutils_fct_to_int_cpp`, x, inplace)
}

starts_from_1_cpp <- function(tbl, on, i, min_lookup, cardinality) {
    .Call(`_CKutils_starts_from_1_cpp`, tbl, on, i, min_lookup, cardinality)
}

dtsubset <- function(x, rows, cols) {
    .Call(`_CKutils_dtsubset`, x, rows, cols)
}

#' Compute Quantiles Using Default R Type 7 Method
#'
#' This function computes quantiles for a numeric vector using the default R method (type 7).
#' It handles missing values and can remove them if requested.
#'
#' @param x A numeric vector from which quantiles are computed.
#' @param probs A numeric vector of probabilities for which quantiles are desired.
#' @param na_rm Logical flag indicating whether to remove NA values (default is true).
#'
#' @return A numeric vector containing the computed quantiles corresponding to the probabilities in \code{probs}.
#'
#' @export
fquantile <- function(x, probs, na_rm = TRUE) {
    .Call(`_CKutils_fquantile`, x, probs, na_rm)
}

#' Compute Quantiles by Group
#'
#' This function computes quantiles for subsets of a numeric vector defined by an ID vector.
#' The input vector must be sorted by the ID vector. Optionally, the results can be rounded.
#'
#' @param x A numeric vector from which quantiles are computed.
#' @param q A numeric vector of probabilities for which quantiles are desired.
#' @param id A string vector representing group identifiers. The vector \code{x} must be sorted by \code{id}.
#' @param rounding Logical flag indicating whether to round the quantiles (default is false).
#' @param na_rm Logical flag indicating whether to remove NA values (default is true).
#'
#' @return A list where the first element is a vector of group IDs and subsequent elements are numeric vectors of computed quantiles for each group.
#'
#' @export
fquantile_byid <- function(x, q, id, rounding = FALSE, na_rm = TRUE) {
    .Call(`_CKutils_fquantile_byid`, x, q, id, rounding, na_rm)
}

#' Count TRUE Values in a Logical Vector
#'
#' This function counts the number of TRUE values in a logical vector, with an option to remove missing values.
#'
#' @param x A logical vector.
#' @param na_rm Logical flag indicating whether to remove NA values before counting (default is false).
#'
#' @return An integer representing the number of TRUE values in the vector.
#'
#' @export
count_if <- function(x, na_rm = FALSE) {
    .Call(`_CKutils_count_if`, x, na_rm)
}

#' Proportion of TRUE Values in a Logical Vector
#'
#' This function calculates the proportion of TRUE values in a logical vector, with an option to remove missing values.
#'
#' @param x A logical vector.
#' @param na_rm Logical flag indicating whether to remove NA values before calculating the proportion (default is false).
#'
#' @return A numeric value representing the proportion of TRUE values in the vector.
#'
#' @export
prop_if <- function(x, na_rm = FALSE) {
    .Call(`_CKutils_prop_if`, x, na_rm)
}

#' Clamp a Numeric Vector Within a Range
#'
#' This function clamps (limits) the values of a numeric vector to lie within a specified range [a, b].
#' Values below a are set to a and values above b are set to b. Vector arguments a and b support recycling.
#' Optionally, the operation can be performed in-place.
#'
#' @param x A numeric vector to be clamped.
#' @param a A numeric vector of lower bounds (supports recycling, default is 0.0).
#' @param b A numeric vector of upper bounds (supports recycling, default is 1.0).
#' @param inplace Logical flag indicating whether to modify the input vector in place (default is false).
#'
#' @return A numeric vector with values clamped to the range [a, b].
#'
#' @export
fclamp <- function(x, a = as.numeric( c(0.0)), b = as.numeric( c(1.0)), inplace = FALSE) {
    .Call(`_CKutils_fclamp`, x, a, b, inplace)
}

#' Clamp an Integer Vector Within a Range
#'
#' This function clamps the values of an integer vector to lie within a specified range [a, b].
#' Values below a are set to a and values above b are set to b. Optionally, the operation can be performed in-place.
#'
#' @param x An integer vector to be clamped.
#' @param a The lower bound (default is 0).
#' @param b The upper bound (default is 1).
#' @param inplace Logical flag indicating whether to modify the input vector in place (default is false).
#'
#' @return An integer vector with values clamped to the range [a, b].
#'
#' @export
fclamp_int <- function(x, a = 0L, b = 1L, inplace = FALSE) {
    .Call(`_CKutils_fclamp_int`, x, a, b, inplace)
}

#' Check Numeric Vector Equality Within Tolerance
#'
#' This function checks whether all non-missing elements in a numeric vector are equal
#' within a specified tolerance. Differences between elements that are less than or equal
#' to the tolerance are considered negligible.
#'
#' @param x A numeric vector to test for equality.
#' @param tol A tolerance value. Differences below or equal to this value are considered equal.
#'
#' @return A logical value: TRUE if all non-missing elements are equal within the tolerance,
#'         and FALSE otherwise.
#'
#' @export
fequal <- function(x, tol) {
    .Call(`_CKutils_fequal`, x, tol)
}

#' Normalise a Numeric Vector to the 0-1 Range
#'
#' This function normalises a numeric vector so that its values are scaled to lie within the 0 to 1 range.
#' If all elements in the vector are identical, the function returns a vector of ones.
#'
#' @param x A numeric vector to be normalised.
#'
#' @return A numeric vector with values scaled between 0 and 1.
#'
#' @export
fnormalise <- function(x) {
    .Call(`_CKutils_fnormalise`, x)
}

#' Perform Linear Interpolation
#'
#' This function performs linear interpolation for a set of points.
#'
#' @param xp A numeric vector of new x values at which to interpolate.
#' @param x0 A numeric vector of original x values (starting points for interpolation).
#' @param x1 A numeric vector of original x values (ending points for interpolation).
#' @param y0 A numeric vector of original y values corresponding to x0.
#' @param y1 A numeric vector of original y values corresponding to x1.
#'
#' @return A numeric vector of interpolated y values corresponding to \code{xp}.
#'
#' @export
lin_interpolation <- function(xp, x0, x1, y0, y1) {
    .Call(`_CKutils_lin_interpolation`, xp, x0, x1, y0, y1)
}

#' Carry Forward Values in an Integer Vector
#'
#' Propagates a specific value forward through an integer vector based on person ID markers.
#' When the previous element equals the target value and the current position is not a new person,
#' the target value is carried forward to the current position.
#'
#' **Important**: The input data must be grouped by person ID and sorted by year/time within each person.
#' This ensures proper temporal ordering for the carry-forward operation.
#'
#' **Missing Values**: Missing values (NA) in the input vectors are handled gracefully. Positions
#' with missing person ID markers or values are skipped during processing, preserving existing values.
#'
#' @param x An integer vector to process (must be sorted by year/time within person)
#' @param pid_mrk A logical vector marking new person IDs (TRUE for new person, FALSE otherwise).
#'   Data must be grouped by person and sorted by year/time.
#' @param y The integer value to carry forward
#' @param byref Logical; if TRUE, modifies `x` in place, if FALSE returns a new vector
#' @return An integer vector with values carried forward according to the rules
#' @export
carry_forward <- function(x, pid_mrk, y, byref) {
    .Call(`_CKutils_carry_forward`, x, pid_mrk, y, byref)
}

#' Carry Forward with Incremental Values
#'
#' Propagates and increments values forward through an integer vector based on person ID markers.
#' The function operates in two distinct modes controlled by the `recur` parameter:
#'
#' **Non-Recursive Mode (recur = FALSE):**
#' - At each position i, if the position is not a new person AND the previous value >= y,
#'   then set current value = previous value + 1
#' - This creates continuously incrementing sequences (y, y+1, y+2, y+3, ...) within each person
#' - Incrementing stops only when a new person boundary is encountered
#'
#' **Recursive Mode (recur = TRUE):**
#' - At each position i, if the position is not a new person AND both current value >= y AND previous value >= y,
#'   then set current value = previous value + 1
#' - This requires both the current and previous positions to already be above threshold y
#' - If the current value drops below y, incrementing stops and must be "restarted" by having both values >= y again
#'
#' **Important**: The input data must be grouped by person ID and sorted by year/time within each person.
#' This ensures proper temporal ordering for the incremental carry-forward operation.
#'
#' **Missing Values**: Missing values (NA) in the input vectors are handled gracefully. Positions
#' with missing person ID markers or values are skipped during processing, preserving existing values.
#'
#' @param x An integer vector to process (must be sorted by year/time within person)
#' @param pid_mrk A logical vector marking new person IDs (TRUE for new person, FALSE otherwise).
#'   Data must be grouped by person and sorted by year/time.
#' @param recur Logical; if FALSE (non-recursive), continuously increment when previous >= y;
#'   if TRUE (recursive), increment only when both current >= y AND previous >= y
#' @param y The threshold value for triggering incremental carry-forward behaviour
#' @param byref Logical; if TRUE, modifies `x` in place, if FALSE returns a new vector
#' @return An integer vector with incremented values carried forward according to the specified mode
#' @export
carry_forward_incr <- function(x, pid_mrk, recur, y, byref) {
    .Call(`_CKutils_carry_forward_incr`, x, pid_mrk, recur, y, byref)
}

#' Carry Values Backward with Decrementation
#'
#' Propagates values backward through an integer vector, decrementing values as it goes.
#' The function processes the vector from end to beginning, reducing values by 1 when
#' moving backward, respecting person ID boundaries.
#'
#' **Important**: The input data must be grouped by person ID and sorted by year/time within each person.
#' This ensures proper temporal ordering for the backward propagation operation.
#'
#' @param x An integer vector to process (must be sorted by year/time within person)
#' @param pid_mrk A logical vector marking new person IDs (TRUE for new person, FALSE otherwise).
#'   Data must be grouped by person and sorted by year/time.
#' @param y The threshold value for backward propagation
#' @return An integer vector with values carried backward and decremented
#' @export
carry_backward_decr <- function(x, pid_mrk, y = 0L) {
    .Call(`_CKutils_carry_backward_decr`, x, pid_mrk, y)
}

#' Create New Simulant Markers
#'
#' Creates a logical vector marking the positions where new simulants (persons) begin
#' based on changes in person ID values. The first position is always marked as TRUE.
#' This function is optimised for performance with minimal branching and memory access.
#'
#' **Important**: The input data must be grouped by person ID and sorted by year/time within each person.
#' This ensures correct identification of person boundaries in temporal data.
#'
#' **Missing Values**: Missing values (NA) in person IDs are treated as new simulants.
#' Each NA value will be marked as TRUE (start of new simulant).
#'
#' @param pid An integer vector of person IDs (must be grouped by person and sorted by year/time)
#' @return A logical vector where TRUE indicates the start of a new simulant
#' @export
mk_new_simulant_markers <- function(pid) {
    .Call(`_CKutils_mk_new_simulant_markers`, pid)
}

#' Identify Long Dead Individuals
#'
#' Identifies positions where individuals have been "long dead" based on the previous
#' value being non-zero and the current position not being a new person ID.
#'
#' **Important**: The input data must be grouped by person ID and sorted by year/time within each person.
#' This ensures proper temporal sequencing for identifying long-dead status.
#'
#' @param x An integer vector representing death status or similar (must be sorted by year/time within person)
#' @param pid A logical vector marking new person IDs (TRUE for new person, FALSE otherwise).
#'   Data must be grouped by person and sorted by year/time.
#' @return A logical vector where TRUE indicates a "long dead" individual
#' @export
identify_longdead <- function(x, pid) {
    .Call(`_CKutils_identify_longdead`, x, pid)
}

#' Identify Invitees for Health Screening Programs
#'
#' Determines which eligible individuals should be invited to screening programs
#' based on eligibility, invitation frequency, probabilities, and previous invitations.
#' The function respects minimum intervals between invitations and person ID boundaries.
#'
#' **Important**: The input data must be grouped by person ID and sorted by year/time within each person.
#' This ensures proper tracking of invitation intervals and temporal relationships.
#'
#' **Missing Values**: Missing values (NA) in any of the input vectors result in NA output
#' for that position, ensuring data integrity in the screening process.
#'
#' @param elig An integer vector indicating eligibility (1 = eligible, 0 = not eligible).
#'   Must be sorted by year/time within person.
#' @param prev_inv An integer vector indicating previous invitations (1 = previously invited, 0 = not).
#'   Must be sorted by year/time within person.
#' @param prb A numeric vector of invitation probabilities for each individual.
#'   Must be sorted by year/time within person.
#' @param freq An integer vector of minimum years between invitations for each individual.
#'   Must be sorted by year/time within person.
#' @param pid A logical vector marking new person IDs (TRUE for new person, FALSE otherwise).
#'   Data must be grouped by person and sorted by year/time.
#' @return An integer vector where 1 indicates an invitation should be sent, 0 otherwise, NA for missing inputs
#' @export
identify_invitees <- function(elig, prev_inv, prb, freq, pid) {
    .Call(`_CKutils_identify_invitees`, elig, prev_inv, prb, freq, pid)
}

#' Health Care Effect with Continuation Probability
#'
#' Models the continuation of a health care effect based on a probability of continuation.
#' When the previous time step had the effect (value 1) and it's not a new person,
#' a binomial trial determines if the effect continues.
#'
#' **Important**: The input data must be grouped by person ID and sorted by year/time within each person.
#' This ensures proper temporal sequencing for modelling effect continuation.
#'
#' @param x An integer vector representing health care effect status (1 = present, 0 = absent).
#'   Must be sorted by year/time within person.
#' @param prb_of_continuation A numeric value representing the probability of effect continuation
#' @param pid A logical vector marking new person IDs (TRUE for new person, FALSE otherwise).
#'   Data must be grouped by person and sorted by year/time.
#' @return An integer vector with updated health care effect status
#' @export
hc_effect <- function(x, prb_of_continuation, pid) {
    .Call(`_CKutils_hc_effect`, x, prb_of_continuation, pid)
}

#' Anti-logit Transformation (Inverse Logit)
#'
#' Transforms a real number to a probability using the anti-logit (logistic) function.
#' This is the inverse of the logit transformation, converting log-odds back to probabilities.
#' The function computes exp(x) / (1 + exp(x)).
#'
#' @param x A numeric value to transform (can be any real number)
#' @return A numeric value between 0 and 1 representing a probability
#' @export
antilogit <- function(x) {
    .Call(`_CKutils_antilogit`, x)
}

#' Scramble trajectories with random walks
#'
#' @description
#' Scrambles rank trajectories of individuals using a continuous space random walk.
#' This function is useful for creating synthetic trajectories while ensuring the
#' distribution of exposure quintiles in the population remains uniform.
#'
#' @details
#' The function applies random perturbations to trajectories, where each point is
#' modified based on the previous point plus a random jump. The jumpiness parameter
#' controls the magnitude of these random walks. Values are constrained to remain
#' within the interval (0, 1).
#'
#' For each trajectory (defined by \code{pid == TRUE} markers), the first value remains
#' unchanged, and subsequent values are perturbed based on the previous value and
#' a random exponential jump with mean 0.02 * jumpiness.
#'
#' The random walks use the dqrng package for high-quality random number generation.
#' Seed and RNG type should be set using \code{dqset.seed()} and \code{dqRNGkind()} 
#' from the dqrng package.
#'
#' @param x A numeric vector of values to scramble, typically between 0 and 1.
#' @param pid A logical vector indicating the start of each trajectory 
#'   (\code{TRUE} = start of new trajectory, \code{FALSE} = continuation).
#'   Must be the same length as \code{x}.
#' @param jumpiness A positive numeric value controlling the magnitude of random jumps.
#'   Higher values create larger perturbations. Default is 1.0.
#' @param inplace A logical value indicating whether to modify \code{x} in place (\code{TRUE})
#'   or return a new vector (\code{FALSE}). Default is \code{TRUE}.
#'
#' @return 
#' If \code{inplace = TRUE}, returns \code{NULL} and modifies \code{x} directly.
#' If \code{inplace = FALSE}, returns a new numeric vector with scrambled values.
#'
#' @examples
#' \dontrun{
#' library(dqrng)
#' dqset.seed(42)
#' 
#' # Create sample trajectory data
#' x <- c(0.1, 0.2, 0.3, 0.5, 0.6, 0.7)  # Two trajectories
#' pid <- c(TRUE, FALSE, FALSE, TRUE, FALSE, FALSE)  # Trajectory starts
#' 
#' # Scramble without modifying original
#' scrambled <- fscramble_trajectories(x, pid, jumpiness = 0.5, inplace = FALSE)
#' print(scrambled)
#' 
#' # Scramble in place
#' original_x <- x
#' fscramble_trajectories(x, pid, jumpiness = 1.0, inplace = TRUE)
#' print(x)  # x is now modified
#' 
#' # Use with data.table for multiple trajectories
#' library(data.table)
#' dt <- data.table(
#'   id = rep(1:3, each = 4),
#'   time = rep(1:4, 3),
#'   value = runif(12)
#' )
#' setkey(dt, id, time)
#' dt[, pid := time == 1]  # Mark trajectory starts
#' dt[, scrambled := fscramble_trajectories(value, pid, 
#'                                         jumpiness = 0.8, 
#'                                         inplace = FALSE)]
#' }
#'
#' @seealso
#' \code{\link[dqrng]{dqset.seed}}, \code{\link[dqrng]{dqRNGkind}}
#'
#' @author Chris Kypridemos
#' @export
fscramble_trajectories <- function(x, pid, jumpiness = 1.0, inplace = TRUE) {
    .Call(`_CKutils_fscramble_trajectories`, x, pid, jumpiness, inplace)
}

#' Shift Values by ID Groups
#' 
#' High-performance implementations for shifting/lagging values within groups 
#' defined by ID variables. These functions are optimised for panel data and 
#' time series analysis where values need to be shifted within groups while 
#' preserving group boundaries.
#' 
#' @param x Vector of values to be shifted. Can be numeric, integer, logical, or character.
#' @param lag Integer specifying the lag amount. Positive values create standard lags 
#'   (shift values forward in time), negative values create leads (shift values 
#'   backward in time).
#' @param replace Replacement value for positions that cannot be filled due to 
#'   shifting. For logical vectors, this should be a logical vector with one element.
#' @param id Integer vector of group identifiers. Must be the same length as x. 
#'   Should be sorted for optimal performance. Values are only shifted within 
#'   the same ID group.
#' 
#' @details
#' These functions implement efficient group-aware shifting operations commonly 
#' needed in panel data analysis. Key features include:
#' 
#' \itemize{
#'   \item \strong{Group preservation}: Values are never shifted across different ID groups
#'   \item \strong{Boundary handling}: Positions at group boundaries are filled with replacement values
#'   \item \strong{Bidirectional shifting}: Supports both lags (positive) and leads (negative)
#'   \item \strong{Type preservation}: Maintains original data types and attributes (e.g., factor levels)
#'   \item \strong{High performance}: Optimized C++ implementation with minimal memory allocation
#' }
#' 
#' For positive lag values:
#' \itemize{
#'   \item Values are shifted forward (standard lag operation)
#'   \item First `lag` positions in each group are filled with replacement value
#'   \item `x[i]` becomes `x[i-lag]` if `id[i] == id[i-lag]`, otherwise replacement value
#' }
#' 
#' For negative lag values (leads):
#' \itemize{
#'   \item Values are shifted backward (lead operation) 
#'   \item Last `abs(lag)` positions in each group are filled with replacement value
#'   \item `x[i]` becomes `x[i+abs(lag)]` if `id[i] == id[i+abs(lag)]`, otherwise replacement value
#' }
#' 
#' @return Vector of the same type and length as input `x`, with values shifted 
#'   according to the specified lag and group structure.
#' 
#' @examples
#' # Example data with two groups
#' id <- c(1, 1, 1, 2, 2, 2)
#' values <- c(10, 20, 30, 40, 50, 60)
#' 
#' # Lag by 1 (shift forward)
#' shift_bypidNum(values, lag = 1, replace = NA_real_, id = id)
#' # Result: [NA, 10, 20, NA, 40, 50]
#' 
#' # Lead by 1 (shift backward) 
#' shift_bypidNum(values, lag = -1, replace = NA_real_, id = id)
#' # Result: [20, 30, NA, 50, 60, NA]
#' 
#' # Integer data with factor preservation
#' factors <- factor(c("A", "B", "C", "A", "B", "C"))
#' factors_int <- as.integer(factors)
#' result <- shift_bypidInt(factors_int, lag = 1, replace = NA_integer_, id = id)
#' # Maintains factor attributes
#' 
#' # Logical data
#' logical_vals <- c(TRUE, FALSE, TRUE, FALSE, TRUE, FALSE)
#' shift_bypidBool(logical_vals, lag = 1, replace = FALSE, id = id)
#' 
#' # Character data
#' char_vals <- c("a", "b", "c", "d", "e", "f")
#' shift_bypidStr(char_vals, lag = 1, replace = "missing", id = id)
#' 
#' @seealso 
#' \code{\link[data.table]{shift}} for data.table's shift function,
#' \code{\link[dplyr]{lag}} and \code{\link[dplyr]{lead}} for dplyr alternatives.
#' 
#' @name shift_bypid
#' @rdname shift_bypid
NULL

#' Shift Numeric Values by ID Groups
#' 
#' @description
#' Efficiently shifts numeric values within groups defined by ID variables.
#' Optimized for panel data and time series analysis.
#' 
#' @param x Numeric vector of values to be shifted.
#' @param lag Integer specifying the lag amount. Positive values create standard lags 
#'   (shift values forward in time), negative values create leads (shift values 
#'   backward in time).
#' @param replace Numeric replacement value for positions that cannot be filled.
#' @param id Integer vector of group identifiers. Must be the same length as x. 
#'   Should be sorted for optimal performance. Values are only shifted within 
#'   the same ID group.
#' 
#' @return Numeric vector of the same length as input, with values shifted 
#'   according to the specified lag and group structure.
#' 
#' @export
#' @rdname shift_bypid
shift_bypidNum <- function(x, lag, replace, id) {
    .Call(`_CKutils_shift_bypidNum`, x, lag, replace, id)
}

#' Shift Integer Values by ID Groups
#' 
#' @description
#' Efficiently shifts integer values within groups defined by ID variables.
#' Preserves factor attributes when present, making it suitable for categorical data.
#' 
#' @param x Integer vector of values to be shifted. Factor attributes are preserved.
#' @param lag Integer specifying the lag amount. Positive values create standard lags 
#'   (shift values forward in time), negative values create leads (shift values 
#'   backward in time).
#' @param replace Integer replacement value for positions that cannot be filled.
#' @param id Integer vector of group identifiers. Must be the same length as x. 
#'   Should be sorted for optimal performance. Values are only shifted within 
#'   the same ID group.
#' 
#' @details
#' This function automatically detects and preserves factor attributes including
#' levels and class information. This makes it particularly useful for shifting
#' categorical variables that have been converted to integers.
#' 
#' @return Integer vector of the same length as input, with values shifted 
#'   according to the specified lag and group structure. Factor attributes 
#'   are preserved if present in the input.
#' 
#' @export
#' @rdname shift_bypid
shift_bypidInt <- function(x, lag, replace, id) {
    .Call(`_CKutils_shift_bypidInt`, x, lag, replace, id)
}

#' Shift Logical Values by ID Groups
#' 
#' @description
#' Efficiently shifts logical (boolean) values within groups defined by ID variables.
#' Designed for binary indicators and flag variables in panel data.
#' 
#' @param x Logical vector of values to be shifted.
#' @param lag Integer specifying the lag amount. Positive values create standard lags 
#'   (shift values forward in time), negative values create leads (shift values 
#'   backward in time).
#' @param replace Logical vector with one element specifying the replacement value 
#'   for positions that cannot be filled.
#' @param id Integer vector of group identifiers. Must be the same length as x. 
#'   Should be sorted for optimal performance. Values are only shifted within 
#'   the same ID group.
#' 
#' @details
#' The replacement parameter must be a logical vector (even with just one element)
#' to maintain type consistency. This is particularly useful for shifting binary
#' indicators, treatment flags, or event occurrence variables in longitudinal data.
#' 
#' @return Logical vector of the same length as input, with values shifted 
#'   according to the specified lag and group structure.
#' 
#' @export
#' @rdname shift_bypid
shift_bypidBool <- function(x, lag, replace, id) {
    .Call(`_CKutils_shift_bypidBool`, x, lag, replace, id)
}

#' Shift Character Values by ID Groups
#' 
#' @description
#' Efficiently shifts character (string) values within groups defined by ID variables.
#' Ideal for text data, labels, and categorical variables in panel data analysis.
#' 
#' @param x Character vector of values to be shifted.
#' @param lag Integer specifying the lag amount. Positive values create standard lags 
#'   (shift values forward in time), negative values create leads (shift values 
#'   backward in time).
#' @param replace String replacement value for positions that cannot be filled.
#' @param id Integer vector of group identifiers. Must be the same length as x. 
#'   Should be sorted for optimal performance. Values are only shifted within 
#'   the same ID group.
#' 
#' @details
#' This function handles character data efficiently by converting the replacement
#' value to the appropriate Rcpp::String type internally. It's particularly useful
#' for shifting categorical variables, labels, or any text-based data in 
#' longitudinal datasets.
#' 
#' @return Character vector of the same length as input, with values shifted 
#'   according to the specified lag and group structure.
#' 
#' @export
#' @rdname shift_bypid
shift_bypidStr <- function(x, lag, replace, id) {
    .Call(`_CKutils_shift_bypidStr`, x, lag, replace, id)
}

