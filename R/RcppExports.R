# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

tableRcpp <- function(x) {
    .Call(`_CKutils_tableRcpp`, x)
}

counts <- function(x) {
    .Call(`_CKutils_counts`, x)
}

#' Box-Cox Power Exponential Distribution (BCPEo) - Density Function
#'
#' Density function for the Box-Cox Power Exponential distribution with log link for mu,
#' optimized for SIMD vectorization and unique parameter values.
#'
#' @param x vector of (non-negative) quantiles.
#' @param mu vector of (positive) location parameters.
#' @param sigma vector of (positive) scale parameters.
#' @param nu vector of shape parameters.
#' @param tau vector of (positive) shape parameters.
#' @param log_ logical; if TRUE, densities are returned on the log scale.
#'
#' @details
#' The Box-Cox Power Exponential (BCPEo) distribution is a four-parameter continuous
#' distribution defined on the positive real line. The BCPEo variant uses a log link
#' for the location parameter mu.
#'
#' The probability density function is given by:
#' \deqn{f(x|\mu,\sigma,\nu,\tau) = \frac{1}{\sigma x^{\nu}} \frac{f_T(z)}{F_T(1/(\sigma|\nu|))}}
#' where \eqn{z = (x^{\nu} - 1)/(\nu\sigma)} when \eqn{\nu \neq 0} and 
#' \eqn{z = \log(x)/\sigma} when \eqn{\nu = 0}, and \eqn{f_T} and \eqn{F_T} are 
#' the density and distribution functions of a specific T distribution.
#'
#' This implementation is optimized for cases where tau values are rarely repeated,
#' using SIMD vectorization and per-element computation without caching.
#'
#' @return A numeric vector of densities.
#'
#' @references
#' Rigby, R. A. and Stasinopoulos, D. M. (2003) Flexible regression smoothing 
#' using GAMLSS. Applied Statistics, 52, 229-237.
#'
#' Stasinopoulos, D. M., Rigby, R. A., Heller, G. Z., Voudouris, V., and 
#' De Bastiani, F. (2017) Flexible Regression and Smoothing: Using GAMLSS in R,
#' Chapman and Hall/CRC.
#'
#' @note
#' This implementation is based on the gamlss.dist package dBCPEo function
#' but optimized for performance with unique parameter values and SIMD vectorization.
#'
#' @examples
#' # Basic usage
#' x <- c(1, 2, 3, 4, 5)
#' mu <- c(2, 2, 2, 2, 2)
#' sigma <- c(0.5, 0.5, 0.5, 0.5, 0.5)
#' nu <- c(1, 1, 1, 1, 1)
#' tau <- c(2, 2, 2, 2, 2)
#' 
#' # Calculate densities
#' fdBCPEo(x, mu, sigma, nu, tau)
#' 
#' # Log densities
#' fdBCPEo(x, mu, sigma, nu, tau, log_ = TRUE)
#'
#' @seealso \code{\link{fpBCPEo}}, \code{\link{fqBCPEo}}
#' @export
fdBCPEo <- function(x, mu, sigma, nu, tau, log_ = FALSE) {
    .Call(`_CKutils_fdBCPEo`, x, mu, sigma, nu, tau, log_)
}

#' Box-Cox Power Exponential Distribution (BCPEo) - Distribution Function
#'
#' Distribution function for the Box-Cox Power Exponential distribution with log link for mu,
#' optimized for SIMD vectorization and unique parameter values.
#'
#' @param q vector of (non-negative) quantiles.
#' @param mu vector of (positive) location parameters.
#' @param sigma vector of (positive) scale parameters.
#' @param nu vector of shape parameters.
#' @param tau vector of (positive) shape parameters.
#' @param lower_tail logical; if TRUE (default), probabilities are P(X ≤ x), 
#'        otherwise P(X > x).
#' @param log_p logical; if TRUE, probabilities p are given as log(p).
#'
#' @details
#' The Box-Cox Power Exponential (BCPEo) distribution is a four-parameter continuous
#' distribution defined on the positive real line. This function computes the
#' cumulative distribution function (CDF).
#'
#' The cumulative distribution function is given by:
#' \deqn{F(x|\mu,\sigma,\nu,\tau) = \frac{F_T(z) - F_T(-1/(\sigma|\nu|))}{F_T(1/(\sigma|\nu|))}}
#' where \eqn{z = (x^{\nu} - 1)/(\nu\sigma)} when \eqn{\nu \neq 0} and 
#' \eqn{z = \log(x)/\sigma} when \eqn{\nu = 0}, and \eqn{F_T} is the 
#' distribution function of a specific T distribution.
#'
#' This implementation is optimized for cases where tau values are rarely repeated,
#' using SIMD vectorization and per-element computation without caching.
#'
#' @return A numeric vector of probabilities.
#'
#' @references
#' Rigby, R. A. and Stasinopoulos, D. M. (2003) Flexible regression smoothing 
#' using GAMLSS. Applied Statistics, 52, 229-237.
#'
#' Stasinopoulos, D. M., Rigby, R. A., Heller, G. Z., Voudouris, V., and 
#' De Bastiani, F. (2017) Flexible Regression and Smoothing: Using GAMLSS in R,
#' Chapman and Hall/CRC.
#'
#' @note
#' This implementation is based on the gamlss.dist package pBCPEo function
#' but optimized for performance with unique parameter values and SIMD vectorization.
#'
#' @examples
#' # Basic usage
#' q <- c(1, 2, 3, 4, 5)
#' mu <- c(2, 2, 2, 2, 2)
#' sigma <- c(0.5, 0.5, 0.5, 0.5, 0.5)
#' nu <- c(1, 1, 1, 1, 1)
#' tau <- c(2, 2, 2, 2, 2)
#' 
#' # Calculate probabilities
#' fpBCPEo(q, mu, sigma, nu, tau)
#' 
#' # Upper tail probabilities
#' fpBCPEo(q, mu, sigma, nu, tau, lower_tail = FALSE)
#' 
#' # Log probabilities
#' fpBCPEo(q, mu, sigma, nu, tau, log_p = TRUE)
#'
#' @seealso \code{\link{fdBCPEo}}, \code{\link{fqBCPEo}}
#' pBCPEo distribution function
#' @export
fpBCPEo <- function(q, mu, sigma, nu, tau, lower_tail = TRUE, log_p = FALSE) {
    .Call(`_CKutils_fpBCPEo`, q, mu, sigma, nu, tau, lower_tail, log_p)
}

#' Box-Cox Power Exponential Distribution (BCPEo) - Quantile Function
#'
#' Quantile function for the Box-Cox Power Exponential distribution with log link for mu,
#' optimized for SIMD vectorization and unique parameter values.
#'
#' @param p vector of probabilities (must be between 0 and 1).
#' @param mu vector of (positive) location parameters.
#' @param sigma vector of (positive) scale parameters.
#' @param nu vector of shape parameters.
#' @param tau vector of (positive) shape parameters.
#' @param lower_tail logical; if TRUE (default), probabilities are P(X ≤ x), 
#'        otherwise P(X > x).
#' @param log_p logical; if TRUE, probabilities p are given as log(p).
#'
#' @details
#' The Box-Cox Power Exponential (BCPEo) distribution is a four-parameter continuous
#' distribution defined on the positive real line. This function computes the
#' quantile function (inverse CDF).
#'
#' The quantile function involves solving:
#' \deqn{F(x|\mu,\sigma,\nu,\tau) = p}
#' where F is the cumulative distribution function. The solution is obtained by
#' first computing the quantile z_a from the underlying T distribution, then
#' transforming back to the original scale.
#'
#' When \eqn{\nu = 0}: \eqn{x = \mu \exp(\sigma z_a)}
#' When \eqn{\nu \neq 0}: \eqn{x = \mu (\nu\sigma z_a + 1)^{1/\nu}}
#'
#' This implementation is optimized for cases where tau values are rarely repeated,
#' using SIMD vectorization and per-element computation without caching.
#'
#' @return A numeric vector of quantiles.
#'
#' @references
#' Rigby, R. A. and Stasinopoulos, D. M. (2003) Flexible regression smoothing 
#' using GAMLSS. Applied Statistics, 52, 229-237.
#'
#' Stasinopoulos, D. M., Rigby, R. A., Heller, G. Z., Voudouris, V., and 
#' De Bastiani, F. (2017) Flexible Regression and Smoothing: Using GAMLSS in R,
#' Chapman and Hall/CRC.
#'
#' @note
#' This implementation is based on the gamlss.dist package qBCPEo function
#' but optimized for performance with unique parameter values and SIMD vectorization.
#'
#' @examples
#' # Basic usage
#' p <- c(0.1, 0.25, 0.5, 0.75, 0.9)
#' mu <- c(2, 2, 2, 2, 2)
#' sigma <- c(0.5, 0.5, 0.5, 0.5, 0.5)
#' nu <- c(1, 1, 1, 1, 1)
#' tau <- c(2, 2, 2, 2, 2)
#' 
#' # Calculate quantiles
#' fqBCPEo(p, mu, sigma, nu, tau)
#' 
#' # Upper tail quantiles
#' fqBCPEo(p, mu, sigma, nu, tau, lower_tail = FALSE)
#' 
#' # Log probabilities
#' log_p <- log(p)
#' fqBCPEo(log_p, mu, sigma, nu, tau, log_p = TRUE)
#'
#' @seealso \code{\link{fdBCPEo}}, \code{\link{fpBCPEo}}
#' qBCPEo quantile function
#' @export
fqBCPEo <- function(p, mu, sigma, nu, tau, lower_tail = TRUE, log_p = FALSE) {
    .Call(`_CKutils_fqBCPEo`, p, mu, sigma, nu, tau, lower_tail, log_p)
}

#' Convert Factor to Integer (C++ Version)
#'
#' This function converts a factor (an integer vector with a "levels" attribute)
#' to its underlying integer representation by stripping away the factor's levels and class attributes.
#' By default, the function does not modify the input by reference (a copy is made), but if `inplace`
#' is set to `true`, the function will modify the input directly.
#'
#' @param x A factor object.
#' @param inplace Logical flag indicating whether to modify the input in place (default: false).
#'
#' @return An integer vector containing the underlying integer codes without factor attributes.
#'
#' @export
fct_to_int_cpp <- function(x, inplace = FALSE) {
    .Call(`_CKutils_fct_to_int_cpp`, x, inplace)
}

starts_from_1_cpp <- function(tbl, on, i, min_lookup, cardinality) {
    .Call(`_CKutils_starts_from_1_cpp`, tbl, on, i, min_lookup, cardinality)
}

dtsubset <- function(x, rows, cols) {
    .Call(`_CKutils_dtsubset`, x, rows, cols)
}

#' Compute Quantiles Using Default R Type 7 Method
#'
#' This function computes quantiles for a numeric vector using the default R method (type 7).
#' It handles missing values and can remove them if requested.
#'
#' @param x A numeric vector from which quantiles are computed.
#' @param probs A numeric vector of probabilities for which quantiles are desired.
#' @param na_rm Logical flag indicating whether to remove NA values (default is true).
#'
#' @return A numeric vector containing the computed quantiles corresponding to the probabilities in \code{probs}.
#'
#' @export
fquantile <- function(x, probs, na_rm = TRUE) {
    .Call(`_CKutils_fquantile`, x, probs, na_rm)
}

#' Compute Quantiles by Group
#'
#' This function computes quantiles for subsets of a numeric vector defined by an ID vector.
#' The input vector must be sorted by the ID vector. Optionally, the results can be rounded.
#'
#' @param x A numeric vector from which quantiles are computed.
#' @param q A numeric vector of probabilities for which quantiles are desired.
#' @param id A string vector representing group identifiers. The vector \code{x} must be sorted by \code{id}.
#' @param rounding Logical flag indicating whether to round the quantiles (default is false).
#' @param na_rm Logical flag indicating whether to remove NA values (default is true).
#'
#' @return A list where the first element is a vector of group IDs and subsequent elements are numeric vectors of computed quantiles for each group.
#'
#' @export
fquantile_byid <- function(x, q, id, rounding = FALSE, na_rm = TRUE) {
    .Call(`_CKutils_fquantile_byid`, x, q, id, rounding, na_rm)
}

#' Count TRUE Values in a Logical Vector
#'
#' This function counts the number of TRUE values in a logical vector, with an option to remove missing values.
#'
#' @param x A logical vector.
#' @param na_rm Logical flag indicating whether to remove NA values before counting (default is false).
#'
#' @return An integer representing the number of TRUE values in the vector.
#'
#' @export
count_if <- function(x, na_rm = FALSE) {
    .Call(`_CKutils_count_if`, x, na_rm)
}

#' Proportion of TRUE Values in a Logical Vector
#'
#' This function calculates the proportion of TRUE values in a logical vector, with an option to remove missing values.
#'
#' @param x A logical vector.
#' @param na_rm Logical flag indicating whether to remove NA values before calculating the proportion (default is false).
#'
#' @return A numeric value representing the proportion of TRUE values in the vector.
#'
#' @export
prop_if <- function(x, na_rm = FALSE) {
    .Call(`_CKutils_prop_if`, x, na_rm)
}

#' Clamp a Numeric Vector Within a Range
#'
#' This function clamps (limits) the values of a numeric vector to lie within a specified range [a, b].
#' Values below a are set to a and values above b are set to b. Optionally, the operation can be performed in-place.
#'
#' @param x A numeric vector to be clamped.
#' @param a The lower bound (default is 0.0).
#' @param b The upper bound (default is 1.0).
#' @param inplace Logical flag indicating whether to modify the input vector in place (default is false).
#'
#' @return A numeric vector with values clamped to the range [a, b].
#'
#' @export
fclamp <- function(x, a = 0.0, b = 1.0, inplace = FALSE) {
    .Call(`_CKutils_fclamp`, x, a, b, inplace)
}

#' Clamp an Integer Vector Within a Range
#'
#' This function clamps the values of an integer vector to lie within a specified range [a, b].
#' Values below a are set to a and values above b are set to b. Optionally, the operation can be performed in-place.
#'
#' @param x An integer vector to be clamped.
#' @param a The lower bound (default is 0).
#' @param b The upper bound (default is 1).
#' @param inplace Logical flag indicating whether to modify the input vector in place (default is false).
#'
#' @return An integer vector with values clamped to the range [a, b].
#'
#' @export
fclamp_int <- function(x, a = 0L, b = 1L, inplace = FALSE) {
    .Call(`_CKutils_fclamp_int`, x, a, b, inplace)
}

#' Check Numeric Vector Equality Within Tolerance
#'
#' This function checks whether all non-missing elements in a numeric vector are equal
#' within a specified tolerance. Differences between elements that are less than or equal
#' to the tolerance are considered negligible.
#'
#' @param x A numeric vector to test for equality.
#' @param tol A tolerance value. Differences below or equal to this value are considered equal.
#'
#' @return A logical value: TRUE if all non-missing elements are equal within the tolerance,
#'         and FALSE otherwise.
#'
#' @export
fequal <- function(x, tol) {
    .Call(`_CKutils_fequal`, x, tol)
}

#' Normalize a Numeric Vector to the 0-1 Range
#'
#' This function normalizes a numeric vector so that its values are scaled to lie within the 0 to 1 range.
#' If all elements in the vector are identical, the function returns a vector of ones.
#'
#' @param x A numeric vector to be normalized.
#'
#' @return A numeric vector with values scaled between 0 and 1.
#'
#' @export
fnormalise <- function(x) {
    .Call(`_CKutils_fnormalise`, x)
}

#' Perform Linear Interpolation
#'
#' This function performs linear interpolation for a set of points.
#'
#' @param xp A numeric vector of new x values at which to interpolate.
#' @param x0 A numeric vector of original x values (starting points for interpolation).
#' @param x1 A numeric vector of original x values (ending points for interpolation).
#' @param y0 A numeric vector of original y values corresponding to x0.
#' @param y1 A numeric vector of original y values corresponding to x1.
#'
#' @return A numeric vector of interpolated y values corresponding to \code{xp}.
#'
#' @export
lin_interpolation <- function(xp, x0, x1, y0, y1) {
    .Call(`_CKutils_lin_interpolation`, xp, x0, x1, y0, y1)
}

